{"version":3,"sources":["promisify.ts"],"names":[],"mappings":";;AACA;;;;;;;;;GASG;AACH,SAAwB,SAAS,CAAK,EAAY,EAAE,KAAiB;IAAjB,sBAAA,EAAA,YAAiB;IACpE,OAAO;QAAS,cAAO;aAAP,UAAO,EAAP,qBAAO,EAAP,IAAO;YAAP,yBAAO;;QACtB,OAAO,IAAI,OAAO,CAAK,UAAU,OAAiB,EAAE,MAAgB;YACnE,+DAA+D;YAC/D,IAAI,CAAC,IAAI,CAAE,UAAU,GAAW,EAAE,GAAQ;gBACzC,gEAAgE;gBAChE,IAAK,GAAG,EAAG;oBACV,MAAM,CAAE,GAAG,CAAE,CAAC;iBACd;qBACI;oBACJ,OAAO,CAAE,GAAG,CAAE,CAAC;iBACf;YACF,CAAC,CAAE,CAAC;YAEJ,EAAE,CAAC,KAAK,CAAE,KAAK,IAAI,EAAE,EAAE,IAAI,CAAE,CAAC;QAC/B,CAAC,CAAE,CAAC;IACL,CAAC,CAAC;AACH,CAAC;AAjBD,4BAiBC","file":"promisify.js","sourcesContent":["\n/**\n * Wrap an async function which uses a callback for completion in a Promise\n * so it can be used with `await`.\n *\n * @export\n * @template T Return type\n * @param {Function} fn Function to execute\n * @param {*} [scope=null] Scope\n * @returns {Function} Promise wrapper function\n */\nexport default function promisify<T>( fn: Function, scope: any = null ): Function {\n\treturn function(...args): Promise<T> {\n\t\treturn new Promise<T>( function( resolve: Function, reject: Function ) {\n\t\t\t// Assume the callback handler goes at the end of the arguments\n\t\t\targs.push( function( err: object, val: any ) {\n\t\t\t\t// Assume that err is the first argument and value is the second\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve( val );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tfn.apply( scope || fn, args );\n\t\t} );\n\t};\n}\n"]}