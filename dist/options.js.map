{"version":3,"sources":["options.ts"],"names":[],"mappings":"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","file":"options.js","sourcesContent":["import knex from 'knex';\n\nfunction isNumeric(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nexport interface IOption {\n    label: string;\n    value: string|number;\n}\n\nexport type IRenderer = ( row: object ) => string;\nexport type CustomOptions = ( db: knex ) => Promise<IOption[]>;\n\n/**\n * The Options class provides a convenient method of specifying where Editor\n * should get the list of options for a `select`, `radio` or `checkbox` field.\n * This is normally from a table that is _left joined_ to the main table being\n * edited, and a list of the values available from the joined table is shown to\n * the end user to let them select from.\n *\n * `Options` instances are used with the {@link Field.options} method.\n *\n * @export\n * @class Options\n */\nexport default class Options {\n    private _table: string;\n    private _value: string;\n    private _label: string[];\n    private _limit: number;\n    private _renderer: IRenderer;\n    private _where: any;\n    private _order: string;\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n    /**\n     * Get the column(s) to be used for the label\n     *\n     * @returns {string[]} Label columns\n     */\n    public label(): string[];\n    /**\n     * Set the column(s) to be used for the label\n     *\n     * @param {string[]} label Database column names\n     * @returns {Options} Self for chaining\n     */\n    public label(label: string[]): Options;\n    public label(label?: string[]): any {\n        if ( label === undefined ) {\n            return this._label;\n        }\n\n        if ( Array.isArray( label ) ) {\n            this._label = label;\n        }\n        else {\n            this._label = [ label ];\n        }\n\n        return this;\n    }\n\n    /**\n     * Get the currently applied LIMIT\n     *\n     * @returns {number} Limit\n     */\n    public limit(): number;\n    /**\n     * Set the LIMIT clause to limit the number of records returned\n     *\n     * @param {number} limit Limit\n     * @returns {Options} Self for chaining\n     */\n    public limit(limit: number): Options;\n    public limit(limit?: number): any {\n        if ( limit === undefined ) {\n            return this._limit;\n        }\n\n        this._limit = limit;\n        return this;\n    }\n\n    /**\n     * Get the ORDER BY clause for the SQL.\n     *\n     * @returns {string} ORDER BY clause\n     */\n    public order(): string;\n    /**\n     * Set the ORDER BY clause to use in the SQL. If this option is not\n     * provided the ordering will be based on the rendered output, either\n     * numerically or alphabetically based on the data returned by the renderer.\n     *\n     * @param {string} order ORDER BY statement\n     * @returns {Options} Self for chaining\n     */\n    public order(order: string): Options;\n    public order(order?: string): any {\n        if ( order === undefined ) {\n            return this._order;\n        }\n\n        this._order = order;\n        return this;\n    }\n\n    /**\n     * Get the configured label renderer\n     *\n     * @returns {IRenderer} Self for chaining\n     */\n    public render(): IRenderer;\n    /**\n     * Set the label renderer. The renderer can be used to combine\n     * multiple database columns into a single string that is shown as the label\n     * to the end user in the list of options.\n     *\n     * @param {IRenderer} fn Renderering function\n     * @returns {Options} Self for chaining\n     */\n    public render(fn: IRenderer): Options;\n    public render(fn?: IRenderer): any {\n        if ( fn === undefined ) {\n            return this._renderer;\n        }\n\n        this._renderer = fn;\n        return this;\n    }\n\n    /**\n     * Get the table that the options will be gathered from.\n     *\n     * @returns {string} Table name\n     */\n    public table(): string;\n    /**\n     * Set the database table from which to gather the options for the list.\n     *\n     * @param {string} table Table name\n     * @returns {Options} Self for chaining\n     */\n    public table(table: string): Options;\n    public table(table?: string): any {\n        if ( table === undefined ) {\n            return this._table;\n        }\n\n        this._table = table;\n        return this;\n    }\n\n    /**\n     * Get the column name to use for the value in the options list.\n     *\n     * @returns {string} Column name\n     */\n    public value(): string;\n    /**\n     * Set the column name to use for the value in the options list. This would\n     * normally be the primary key for the table.\n     *\n     * @param {string} value Column name\n     * @returns {Options} Self for chaining\n     */\n    public value(value: string): Options;\n    public value(value?: string): any {\n        if ( value === undefined ) {\n            return this._value;\n        }\n\n        this._value = value;\n        return this;\n    }\n\n    /**\n     * Get the WHERE condition for this option set.\n     *\n     * @returns {*} Knex WHERE condition\n     */\n    public where(): any;\n    /**\n     * Set the method to use for a WHERE condition if one is to be applied to\n     * the query to get the options.\n     *\n     * @param {*} where Knex WHERE condition\n     * @returns {Options} Self for chaining\n     */\n    public where(where: any): Options;\n    public where(where?: any): any {\n        if ( where === undefined ) {\n            return this._where;\n        }\n\n        this._where = where;\n        return this;\n    }\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t */\n\n     /**\n      * @ignore\n      */\n    public async exec( db: knex ): Promise<IOption[]> {\n        let label = this._label;\n        let value = this._value;\n        let formatter = this._renderer;\n\n        // Create a list of the fields that we need to get from the db\n        let fields = [ value ].concat( label );\n\n        // We need a default formatter if one isn't provided\n        if ( ! formatter ) {\n            formatter = function( row ) {\n                let a = [];\n\n                for ( let i = 0, ien = label.length ; i < ien ; i++ ) {\n                    a.push( row[ label[i] ] );\n                }\n\n                return a.join(' ');\n            };\n        }\n\n        // Get the data\n        let q = db( this._table )\n            .distinct( fields )\n            .select();\n\n        if ( this._where ) {\n            q.where( this._where );\n        }\n\n        if ( this._order ) {\n            q.order( this._order );\n        }\n\n        if ( this._limit ) {\n            q.limit( this.limit );\n        }\n\n        let res = await q;\n        let out = [];\n\n        // Create the output array\n        for ( let i = 0, ien = res.length ; i < ien ; i++ ) {\n            out.push( {\n                label: formatter( res[i] ),\n                value: res[i][ value ]\n            } );\n        }\n\n        // Only sort if there was no SQL order field\n        if ( ! this._order ) {\n            out.sort( function( a, b ) {\n                if ( isNumeric(a) && isNumeric(b) ) {\n                    return (a.label * 1) - (b.label * 1);\n                }\n                return a.label < b.label ?\n                    -1 : a.label > b.label ?\n                        1 :\n                        0;\n            } );\n        }\n\n        return out;\n    }\n}\n"]}