{"version":3,"sources":["options.ts"],"names":[],"mappings":"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","file":"options.js","sourcesContent":["import * as knex from 'knex';\n\nfunction isNumeric(n) {\n\treturn !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nexport interface IOption {\n\tlabel: string;\n\tvalue: string|number;\n}\n\nexport type IRenderer = ( row: object ) => string;\nexport type CustomOptions = ( db: knex ) => Promise<IOption[]>;\n\n/**\n * The Options class provides a convenient method of specifying where Editor\n * should get the list of options for a `select`, `radio` or `checkbox` field.\n * This is normally from a table that is _left joined_ to the main table being\n * edited, and a list of the values available from the joined table is shown to\n * the end user to let them select from.\n *\n * `Options` instances are used with the {@link Field.options} method.\n *\n * @export\n * @class Options\n */\nexport default class Options {\n\tprivate _table: string;\n\tprivate _value: string;\n\tprivate _label: string[];\n\tprivate _limit: number;\n\tprivate _renderer: IRenderer;\n\tprivate _where: any;\n\tprivate _order: string;\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Get the column(s) to be used for the label\n\t *\n\t * @returns {string[]} Label columns\n\t */\n\tpublic label(): string[];\n\t/**\n\t * Set the column(s) to be used for the label\n\t *\n\t * @param {string[]} label Database column names\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic label(label: string[]): Options;\n\tpublic label(label?: string[]): any {\n\t\tif ( label === undefined ) {\n\t\t\treturn this._label;\n\t\t}\n\n\t\tif ( Array.isArray( label ) ) {\n\t\t\tthis._label = label;\n\t\t}\n\t\telse {\n\t\t\tthis._label = [ label ];\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the currently applied LIMIT\n\t *\n\t * @returns {number} Limit\n\t */\n\tpublic limit(): number;\n\t/**\n\t * Set the LIMIT clause to limit the number of records returned\n\t *\n\t * @param {number} limit Limit\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic limit(limit: number): Options;\n\tpublic limit(limit?: number): any {\n\t\tif ( limit === undefined ) {\n\t\t\treturn this._limit;\n\t\t}\n\n\t\tthis._limit = limit;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the ORDER BY clause for the SQL.\n\t *\n\t * @returns {string} ORDER BY clause\n\t */\n\tpublic order(): string;\n\t/**\n\t * Set the ORDER BY clause to use in the SQL. If this option is not\n\t * provided the ordering will be based on the rendered output, either\n\t * numerically or alphabetically based on the data returned by the renderer.\n\t *\n\t * @param {string} order ORDER BY statement\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic order(order: string): Options;\n\tpublic order(order?: string): any {\n\t\tif ( order === undefined ) {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tthis._order = order;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the configured label renderer\n\t *\n\t * @returns {IRenderer} Self for chaining\n\t */\n\tpublic render(): IRenderer;\n\t/**\n\t * Set the label renderer. The renderer can be used to combine\n\t * multiple database columns into a single string that is shown as the label\n\t * to the end user in the list of options.\n\t *\n\t * @param {IRenderer} fn Renderering function\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic render(fn: IRenderer): Options;\n\tpublic render(fn?: IRenderer): any {\n\t\tif ( fn === undefined ) {\n\t\t\treturn this._renderer;\n\t\t}\n\n\t\tthis._renderer = fn;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the table that the options will be gathered from.\n\t *\n\t * @returns {string} Table name\n\t */\n\tpublic table(): string;\n\t/**\n\t * Set the database table from which to gather the options for the list.\n\t *\n\t * @param {string} table Table name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic table(table: string): Options;\n\tpublic table(table?: string): any {\n\t\tif ( table === undefined ) {\n\t\t\treturn this._table;\n\t\t}\n\n\t\tthis._table = table;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the column name to use for the value in the options list.\n\t *\n\t * @returns {string} Column name\n\t */\n\tpublic value(): string;\n\t/**\n\t * Set the column name to use for the value in the options list. This would\n\t * normally be the primary key for the table.\n\t *\n\t * @param {string} value Column name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic value(value: string): Options;\n\tpublic value(value?: string): any {\n\t\tif ( value === undefined ) {\n\t\t\treturn this._value;\n\t\t}\n\n\t\tthis._value = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the WHERE condition for this option set.\n\t *\n\t * @returns {*} Knex WHERE condition\n\t */\n\tpublic where(): any;\n\t/**\n\t * Set the method to use for a WHERE condition if one is to be applied to\n\t * the query to get the options.\n\t *\n\t * @param {*} where Knex WHERE condition\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic where(where: any): Options;\n\tpublic where(where?: any): any {\n\t\tif ( where === undefined ) {\n\t\t\treturn this._where;\n\t\t}\n\n\t\tthis._where = where;\n\t\treturn this;\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t */\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async exec( db: knex ): Promise<IOption[]> {\n\t\tlet label = this._label;\n\t\tlet value = this._value;\n\t\tlet formatter = this._renderer;\n\n\t\t// Create a list of the fields that we need to get from the db\n\t\tlet fields = [ value ].concat( label );\n\n\t\t// We need a default formatter if one isn't provided\n\t\tif ( ! formatter ) {\n\t\t\tformatter = function( row ) {\n\t\t\t\tlet a = [];\n\n\t\t\t\tfor ( let i = 0, ien = label.length ; i < ien ; i++ ) {\n\t\t\t\t\ta.push( row[ label[i] ] );\n\t\t\t\t}\n\n\t\t\t\treturn a.join(' ');\n\t\t\t};\n\t\t}\n\n\t\t// Get the data\n\t\tlet q = db( this._table )\n\t\t\t.distinct( fields )\n\t\t\t.select();\n\n\t\tif ( this._where ) {\n\t\t\tq.where( this._where );\n\t\t}\n\n\t\tif ( this._order ) {\n\t\t\tq.order( this._order );\n\t\t}\n\n\t\tif ( this._limit ) {\n\t\t\tq.limit( this.limit );\n\t\t}\n\n\t\tlet res = await q;\n\t\tlet out = [];\n\n\t\t// Create the output array\n\t\tfor ( let i = 0, ien = res.length ; i < ien ; i++ ) {\n\t\t\tout.push( {\n\t\t\t\tlabel: formatter( res[i] ),\n\t\t\t\tvalue: res[i][ value ]\n\t\t\t} );\n\t\t}\n\n\t\t// Only sort if there was no SQL order field\n\t\tif ( ! this._order ) {\n\t\t\tout.sort( function( a, b ) {\n\t\t\t\tif ( isNumeric(a) && isNumeric(b) ) {\n\t\t\t\t\treturn (a.label * 1) - (b.label * 1);\n\t\t\t\t}\n\t\t\t\treturn a.label < b.label ?\n\t\t\t\t\t-1 : a.label > b.label ?\n\t\t\t\t\t\t1 :\n\t\t\t\t\t\t0;\n\t\t\t} );\n\t\t}\n\n\t\treturn out;\n\t}\n}\n"]}