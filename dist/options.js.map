{"version":3,"sources":["options.ts"],"names":[],"mappings":"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","file":"options.js","sourcesContent":["import * as knex from 'knex';\nimport {Knex} from 'knex';\nimport {ILeftJoin} from './editor';\nimport {leftJoin} from './helpers';\n\nfunction isNumeric(n) {\n\treturn !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nexport interface IOption {\n\tlabel: string;\n\tvalue: string | number;\n}\n\nexport type IRenderer = (row: object) => string;\nexport type CustomOptions = (db: Knex, search?: string) => Promise<IOption[]>;\n\n/**\n * The Options class provides a convenient method of specifying where Editor\n * should get the list of options for a `select`, `radio` or `checkbox` field.\n * This is normally from a table that is _left joined_ to the main table being\n * edited, and a list of the values available from the joined table is shown to\n * the end user to let them select from.\n *\n * `Options` instances are used with the {@link Field.options} method.\n *\n * @export\n * @class Options\n */\nexport default class Options {\n\tprivate _alwaysRefresh: boolean = true;\n\tprivate _customFn: CustomOptions;\n\tprivate _includes: string[] = [];\n\tprivate _searchOnly: boolean = false;\n\tprivate _table: string;\n\tprivate _value: string;\n\tprivate _label: string[];\n\tprivate _leftJoin: ILeftJoin[] = [];\n\tprivate _limit: number;\n\tprivate _renderer: IRenderer;\n\tprivate _where: any;\n\tprivate _order: string | boolean = true;\n\tprivate _manualOpts: IOption[] = [];\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Add extra options to the list, in addition to any obtained from the database\n\t *\n\t * @param label Label\n\t * @param value Value\n\t */\n\tpublic add(label: string, value?: string) {\n\t\tif (value === undefined) {\n\t\t\tvalue = label;\n\t\t}\n\n\t\tthis._manualOpts.push({\n\t\t\tlabel,\n\t\t\tvalue\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the current alwaysRefresh flag\n\t */\n\tpublic alwaysRefresh(): boolean;\n\t/**\n\t * Set the flag to indicate that the options should always be refreshed (i.e. on get, create,\n\t * edit and delete) or only on the initial data load (false).\n\t *\n\t * @param set Flag to set the always refresh to\n\t */\n\tpublic alwaysRefresh(set: boolean): Options;\n\tpublic alwaysRefresh(set?: boolean): any {\n\t\tif (set === undefined) {\n\t\t\treturn this._alwaysRefresh;\n\t\t}\n\n\t\tthis._alwaysRefresh = set;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the function (if set) to get the options\n\t */\n\tpublic fn(): CustomOptions;\n\t/**\n\t * Set the function used to get the options, rather than using the built in DB configuration.\n\t *\n\t * @param set Function to use for the custom options function\n\t */\n\tpublic fn(set: CustomOptions): Options;\n\tpublic fn(set?: CustomOptions): any {\n\t\tif (set === undefined) {\n\t\t\treturn this._customFn;\n\t\t}\n\n\t\tthis._customFn = set;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the list of field names to include in the option objects\n\t */\n\tpublic include(): string[];\n\t/**\n\t * Column names from `value()` and `label()` that should be included in the output object for\n\t * each option, in addition to the value and label.\n\t *\n\t * @param set The list of columns to include in the output\n\t */\n\tpublic include(set: string[] | string): Options;\n\tpublic include(set?: string[] | string): any {\n\t\tif (set === undefined) {\n\t\t\treturn this._includes;\n\t\t}\n\n\t\tif (Array.isArray(set)) {\n\t\t\tthis._includes.push.apply(this._includes, set);\n\t\t}\n\t\telse {\n\t\t\tthis._includes.push(set);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the column(s) to be used for the label\n\t *\n\t * @returns {string[]} Label columns\n\t */\n\tpublic label(): string[];\n\t/**\n\t * Set the column(s) to be used for the label\n\t *\n\t * @param {string[]} label Database column names\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic label(label: string | string[]): Options;\n\tpublic label(label?: string | string[]): any {\n\t\tif (label === undefined) {\n\t\t\treturn this._label;\n\t\t}\n\n\t\tif (Array.isArray(label)) {\n\t\t\tthis._label = label;\n\t\t}\n\t\telse {\n\t\t\tthis._label = [label];\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a left join condition to the Options instance, allowing it to operate\n\t * over multiple tables.\n\t *\n\t * In this form the method will take a function as the second parameter which\n\t * is a Knex callback function allowing a complex join expression to be built.\n\t * @param {string} table Table name to do a join onto\n\t * @param {function} condition\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic leftJoin(table: string, condition: Function): Options;\n\t/**\n\t * Add a left join condition to the Options instance, allowing it to operate\n\t * over multiple tables.\n\t * @param {string} table Table name to do a join onto\n\t * @param {string} field1 Field from the parent table to use as the join link\n\t * @param {string} operator Join condition (`=`, '<`, etc)\n\t * @param {string} field2 Field from the child table to use as the join link\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic leftJoin(table: string, field1: string, operator: string, field2: string): Options;\n\tpublic leftJoin(\n\t\ttable: string,\n\t\tfield1: string | Function,\n\t\toperator: string | undefined = undefined,\n\t\tfield2: string | undefined = undefined\n\t): Options {\n\t\tif (typeof field1 === 'function') {\n\t\t\tthis._leftJoin.push({\n\t\t\t\tfield1: '',\n\t\t\t\tfield2: '',\n\t\t\t\tfn: field1,\n\t\t\t\toperator: '',\n\t\t\t\ttable\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tthis._leftJoin.push({\n\t\t\t\tfield1,\n\t\t\t\tfield2,\n\t\t\t\toperator,\n\t\t\t\ttable\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the currently applied LIMIT\n\t *\n\t * @returns {number} Limit\n\t */\n\tpublic limit(): number;\n\t/**\n\t * Set the LIMIT clause to limit the number of records returned\n\t *\n\t * @param {number} limit Limit\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic limit(limit: number): Options;\n\tpublic limit(limit?: number): any {\n\t\tif (limit === undefined) {\n\t\t\treturn this._limit;\n\t\t}\n\n\t\tthis._limit = limit;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the ORDER BY clause for the SQL.\n\t *\n\t * @returns {string} ORDER BY clause\n\t */\n\tpublic order(): string;\n\t/**\n\t * Set the ORDER BY clause to use in the SQL. If this option is `true`\n\t * (which it is by default) the ordering will be based on the rendered output,\n\t * either numerically or alphabetically based on the data returned by the\n\t * renderer. If `false` no ordering will be performed and whatever is returned\n\t * from the database will be used.\n\t *\n\t * @param {string|boolean} order ORDER BY statement\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic order(order: string | boolean): Options;\n\tpublic order(order?: string | boolean): any {\n\t\tif (order === undefined) {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tthis._order = order;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the configured label renderer\n\t *\n\t * @returns {IRenderer} Self for chaining\n\t */\n\tpublic render(): IRenderer;\n\t/**\n\t * Set the label renderer. The renderer can be used to combine\n\t * multiple database columns into a single string that is shown as the label\n\t * to the end user in the list of options.\n\t *\n\t * @param {IRenderer} fn Renderering function\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic render(fn: IRenderer): Options;\n\tpublic render(fn?: IRenderer): any {\n\t\tif (fn === undefined) {\n\t\t\treturn this._renderer;\n\t\t}\n\n\t\tthis._renderer = fn;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the current search only flag\n\t */\n\tpublic searchOnly(): boolean;\n\t/**\n\t * Set the flag to indicate if the options should always be refreshed (i.e. on get, create\n\t * and edit) or only on the initial data load (false).\n\t *\n\t * @param set Flag to set the search only option to\n\t */\n\tpublic searchOnly(set: boolean): Options;\n\tpublic searchOnly(set?: boolean): any {\n\t\tif (set === undefined) {\n\t\t\treturn this._searchOnly;\n\t\t}\n\n\t\tthis._searchOnly = set;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the table that the options will be gathered from.\n\t *\n\t * @returns {string} Table name\n\t */\n\tpublic table(): string;\n\t/**\n\t * Set the database table from which to gather the options for the list.\n\t *\n\t * @param {string} table Table name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic table(table: string): Options;\n\tpublic table(table?: string): any {\n\t\tif (table === undefined) {\n\t\t\treturn this._table;\n\t\t}\n\n\t\tthis._table = table;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the column name to use for the value in the options list.\n\t *\n\t * @returns {string} Column name\n\t */\n\tpublic value(): string;\n\t/**\n\t * Set the column name to use for the value in the options list. This would\n\t * normally be the primary key for the table.\n\t *\n\t * @param {string} value Column name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic value(value: string): Options;\n\tpublic value(value?: string): any {\n\t\tif (value === undefined) {\n\t\t\treturn this._value;\n\t\t}\n\n\t\tthis._value = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the WHERE condition for this option set.\n\t *\n\t * @returns {*} Knex WHERE condition\n\t */\n\tpublic where(): any;\n\t/**\n\t * Set the method to use for a WHERE condition if one is to be applied to\n\t * the query to get the options.\n\t *\n\t * @param {*} where Knex WHERE condition\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic where(where: any): Options;\n\tpublic where(where?: any): any {\n\t\tif (where === undefined) {\n\t\t\treturn this._where;\n\t\t}\n\n\t\tthis._where = where;\n\t\treturn this;\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t */\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async exec(\n\t\tdb: Knex,\n\t\trefresh,\n\t\tsearch: string = null,\n\t\tfind: any[] = null\n\t): Promise<IOption[] | false> {\n\t\t// If search only, and not a search action, then just return false\n\t\tif (this.searchOnly() && search === null && find === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Only get the options if doing a full load, or always is set\n\t\tif (refresh === true && !this.alwaysRefresh()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._customFn) {\n\t\t\treturn this._customFn(db, search);\n\t\t}\n\n\t\tlet label = this._label;\n\t\tlet value = this._value;\n\t\tlet formatter = this._renderer;\n\t\tlet out = [];\n\t\tlet max = this._limit;\n\n\t\t// Create a list of the fields that we need to get from the db\n\t\tlet fields = [value].concat(label);\n\n\t\t// We need a default formatter if one isn't provided\n\t\tif (!formatter) {\n\t\t\tformatter = function (row) {\n\t\t\t\tlet a = [];\n\n\t\t\t\tfor (let i = 0, ien = label.length; i < ien; i++) {\n\t\t\t\t\ta.push(row[label[i]]);\n\t\t\t\t}\n\n\t\t\t\treturn a.join(' ');\n\t\t\t};\n\t\t}\n\n\t\t// Get database data\n\t\tlet options = await this.execDb(db, find);\n\n\t\t// Manually added options\n\t\tfor (let i = 0; i < this._manualOpts.length; i++) {\n\t\t\toptions.push(this._manualOpts[i]);\n\t\t}\n\n\t\t// Create the output array\n\t\tfor (let i = 0, ien = options.length; i < ien; i++) {\n\t\t\tlet rowLabel = formatter(options[i]);\n\t\t\tlet rowValue = options[i][value];\n\n\t\t\t// Apply the search to the rendered label. Need to do it here rather than in SQL since\n\t\t\t// the label is rendered in script.\n\t\t\tif (\n\t\t\t\tsearch === null ||\n\t\t\t\tsearch === '' ||\n\t\t\t\trowLabel.toLowerCase().indexOf(search.toLowerCase()) === 0\n\t\t\t) {\n\t\t\t\tlet option = {\n\t\t\t\t\tlabel: rowLabel,\n\t\t\t\t\tvalue: rowValue\n\t\t\t\t};\n\n\t\t\t\t// Add in any columns that are needed for extra data (includes)\n\t\t\t\tfor (let j = 0; j < this._includes.length; j++) {\n\t\t\t\t\tlet inc = this._includes[j];\n\n\t\t\t\t\tif (options[i][inc] !== undefined) {\n\t\t\t\t\t\toption[inc] = options[i][inc];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tout.push(option);\n\t\t\t}\n\n\t\t\t// Limit needs to be done in script space, rather than SQL, to allow for the script\n\t\t\t// based filtering above, and also for when using a custom function\n\t\t\tif (max !== null && out.length >= max) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Local sorting\n\t\tif (this._order === true) {\n\t\t\tout.sort(function (a, b) {\n\t\t\t\tlet aLabel = a.label;\n\t\t\t\tlet bLabel = b.label;\n\n\t\t\t\tif (aLabel === null) {\n\t\t\t\t\taLabel = '';\n\t\t\t\t}\n\n\t\t\t\tif (bLabel === null) {\n\t\t\t\t\tbLabel = '';\n\t\t\t\t}\n\n\t\t\t\tif (isNumeric(aLabel) && isNumeric(bLabel)) {\n\t\t\t\t\treturn aLabel * 1 - bLabel * 1;\n\t\t\t\t}\n\n\t\t\t\treturn aLabel < bLabel ? -1 : aLabel > bLabel ? 1 : 0;\n\t\t\t});\n\t\t}\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * Get the list of options from the database based on the configuration\n\t *\n\t * @param db Database connection\n\t * @param find Values to search for\n\t * @returns List of found options\n\t */\n\tpublic async execDb(db: Knex, find: any[]) {\n\t\tif (!this._table) {\n\t\t\treturn [];\n\t\t}\n\n\t\t// Create a list of the fields that we need to get from the db\n\t\tlet fields = [this._value].concat(this._label);\n\n\t\t// Options query\n\t\tlet q = db\n\t\t\t.select(fields)\n\t\t\t.distinct()\n\t\t\t.from(this._table);\n\n\t\tif (this._where) {\n\t\t\tq.where(this._where);\n\t\t}\n\n\t\tif (Array.isArray(find)) {\n\t\t\tq.whereIn(this._value, find);\n\t\t}\n\n\t\tif (typeof this._order === 'string') {\n\t\t\t// For cases where we are ordering by a field which isn't included in the list\n\t\t\t// of fields to display, we need to add the ordering field, due to the\n\t\t\t// select distinct.\n\t\t\tthis._order.split(',').forEach((val) => {\n\t\t\t\tval = val.toLocaleLowerCase();\n\n\t\t\t\tconst direction = val.match(/( desc| asc)/g);\n\t\t\t\tconst field = val.replace(/( desc| asc$)/, '').trim();\n\n\t\t\t\tif (!fields.includes(field)) {\n\t\t\t\t\tq.select(field);\n\t\t\t\t}\n\n\t\t\t\tq.orderBy(field, direction ? direction[0].trim() : 'asc');\n\t\t\t});\n\t\t}\n\t\telse if (this._order === true) {\n\t\t\t// Attempt to do a database order, needed for `limit()`ed results\n\t\t\tq.orderBy(this._label[0], 'asc');\n\t\t}\n\n\t\tleftJoin(q, this._leftJoin);\n\n\t\tlet res = await q;\n\n\t\treturn res;\n\t}\n\n\t/**\n\t * Get the objects for a set of values.\n\t *\n\t * @param db  Database connection\n\t * @param ids IDs to get\n\t *\n\t * @return array|bool\n\t */\n\tpublic async find(db: Knex, ids: any[]): Promise<IOption[] | false> {\n\t\treturn this.exec(db, false, null, ids);\n\t}\n\n\t/**\n\t * Do a search for data on the source.\n\t *\n\t * @param db   Database connection\n\t * @param term Search term\n\t *\n\t * @return array|bool\n\t */\n\tpublic async search(db: Knex, term: string): Promise<IOption[] | false> {\n\t\treturn this.exec(db, false, term);\n\t}\n}\n"]}