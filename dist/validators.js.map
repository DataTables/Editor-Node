{"version":3,"sources":["validators.ts"],"names":[],"mappings":"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","file":"validators.js","sourcesContent":["import * as knex from 'knex';\nimport * as moment from 'moment';\nimport * as validUrl from 'valid-url';\n\nimport Editor from './editor';\nimport Field from './field';\nimport {default as JoinOptions} from './options';\nimport {IFile} from './upload';\nimport ValidationHost from './validationHost';\nimport ValidationOptions from './validationOptions';\n\n// Note that validators return a Promise to allow async validators, such as\n// checking a value is unique against the database\nexport type IValidator = (val: any, data: object, host: ValidationHost) => Promise<true|string>;\nexport type IFileValidator = (file: IFile) => Promise<true|string>;\n\n/**\n * Validation methods for DataTables Editor fields. All of the methods\n * defined in this class return a function that can be used by\n * {@link Field} instance's {@link Field.Validator} method.\n *\n * Each method may define its own parameters that configure how the\n * formatter operates. For example the `minLen` validator takes information\n * on the minimum length of value to accept.\n *\n * Additionally each method can optionally take a `ValidationOptions`\n * instance that controls common validation options and error messages.\n *\n * The validation functions return `true` for valid data and a string for\n * invalid data, with the string being the error message.\n *\n * @export\n * @class Validator\n */\nexport default class Validator {\n    public static Options = ValidationOptions;\n    public static Host = ValidationHost;\n\n    /**\n     * No validation - all inputs are valid\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static none( cfg: ValidationOptions = null ): IValidator {\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            return true;\n        };\n    }\n\n    /**\n     * Basic validation - this is used to perform the validation provided by the\n     * validation options only. If the validation options pass (e.g. `required`,\n     * `empty` and `optional`) then the validation will pass regardless of the\n     * actual value.\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static basic( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n\n            return common === false ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Required field - there must be a value and it must be a non-empty value\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static required( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n        opts.empty = false;\n        opts.optional = false;\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n\n            return common === false ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Optional field, but if given there must be a non-empty value\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static notEmpty( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n        opts.empty = false;\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n\n            return common === false ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Validate an input as a boolean value.\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static boolean( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            if ( val === true || val === 1 || val === '1' || val === 'true' || val === 't' ||\n                 val === 'on' || val === 'yes' || val === false || val === 0 || val === '0' ||\n                 val === 'false' || val === 'f' || val === 'off' || val === 'no' )\n            {\n                return true;\n            }\n\n            return opts.message;\n        };\n    }\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Number validation methods\n\t */\n\n    /**\n     * Check that any input is numeric.\n     *\n     * @static\n     * @param {string} [decimal='.'] Character to use as the decimal place\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static numeric( decimal: string = '.', cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            if ( decimal !== '.' ) {\n                val = val.toString().replace(decimal, '.');\n            }\n\n            return isNaN( parseFloat( val ) ) ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Check for a numeric input and that it is greater than a given value.\n     *\n     * @static\n     * @param {number} min Minimum value\n     * @param {string} [decimal='.'] Character to use as the decimal place\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static minNum( min: number, decimal: string = '.', cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let numeric = await Validator.numeric( decimal, opts )( val, data, host );\n            if ( numeric !== true ) {\n                return opts.message;\n            }\n\n            if ( decimal !== '.' ) {\n                val = val.toString().replace(decimal, '.');\n            }\n\n            return val < min ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Check for a numeric input and that it is less than a given value.\n     *\n     * @static\n     * @param {number} max Maximum value\n     * @param {string} [decimal='.'] Character to use as the decimal place\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static maxNum( max: number, decimal: string = '.', cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let numeric = await Validator.numeric( decimal, opts )( val, data, host );\n            if ( numeric !== true ) {\n                return opts.message;\n            }\n\n            if ( decimal !== '.' ) {\n                val = val.toString().replace(decimal, '.');\n            }\n\n            return val > max ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Check for a numeric input and that it is in between two given values.\n     *\n     * @static\n     * @param {number} min Minimum value\n     * @param {number} max Maximum value\n     * @param {string} [decimal='.'] Character to use as the decimal place\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static minMaxNum(\n        min: number,\n        max: number,\n        decimal: string = '.',\n        cfg: ValidationOptions = null\n    ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let numeric = await Validator.numeric( decimal, opts )( val, data, host );\n            if ( numeric !== true ) {\n                return opts.message;\n            }\n\n            if ( decimal !== '.' ) {\n                val = val.toString().replace(decimal, '.');\n            }\n\n            return val < min || val > max ?\n                opts.message :\n                true;\n        };\n    }\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * String validation methods\n\t */\n\n    /**\n     * Validate an input as an e-mail address.\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static email( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            let re = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n\n            return re.test( val ) ?\n                true :\n                opts.message;\n        };\n    }\n\n    /**\n     * Validate a string has a minimum length.\n     *\n     * @static\n     * @param {number} min Minimum length\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static minLen( min: number, cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            return val.length < min ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Validate a string is less or equal to a maximum length.\n     *\n     * @static\n     * @param {number} max Maximum length\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static maxLen( max: number, cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            return val.length > max ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Require a string with a certain minimum or maximum number of characters.\n     *\n     * @static\n     * @param {number} min Minimum length\n     * @param {number} max Maximum length\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static minMaxLen( min: number, max: number, cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            return val.length < min || val.length > max ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Validate as an IP address.\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static ip( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            let a = val.split('.');\n            if ( a.length !== 4 ) {\n                return opts.message;\n            }\n\n            for ( let i = 0 ; i < 4 ; i++ ) {\n                let parsed = parseInt( a[i], 10 );\n                if ( parsed !== a[i] * 1 ) {\n                    return opts.message;\n                }\n\n                if ( parsed < 0 || parsed > 255 ) {\n                    return opts.message;\n                }\n            }\n\n            return true;\n        };\n    }\n\n    /**\n     * Validate as a URL.\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static url( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            return ! validUrl.isHttpUri( val ) ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Check if string could contain an XSS attack string\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static xss( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            let field = host.field;\n\n            return field.xssSafety( val ) !== val ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Confirm that the value submitted is in a list of allowable values\n     *\n     * @static\n     * @param {any[]} values List of values that are valid\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static values( values: any[], cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            return values.includes( val ) ?\n                true :\n                opts.message;\n        };\n    }\n\n    /**\n     * Ensure that the submitted string does not contain HTML tags\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static noTags( cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            return val.toString().test(/<.*>/) ?\n                opts.message :\n                true;\n        };\n    }\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    * Date validation methods\n    */\n\n    /**\n     * Check that a valid date input is given. Uses MomentJS\n     *\n     * @static\n     * @param {string} format MomentJS date format\n     * @param {string} [locale=null] MomentJS locale\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @returns {IValidator} Configured validation function\n     */\n    public static dateFormat( format: string, locale: string = null, cfg: ValidationOptions = null ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            let res = locale ?\n                moment( val, format, locale, true ).isValid() :\n                moment( val, format, true ).isValid();\n\n            return ! res ?\n                opts.message :\n                true;\n        };\n    }\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    * Database validation\n    */\n\n    /**\n     * Check that the given value is unique in the database\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @param {string} [column=null] Column name to use to check as a unique\n     *   value. If not given the host field's database column name is used\n     * @param {string} [table=null] Table to check that this value is uniquely\n     *   valid on. If not given the host Editor's table name is used\n     * @param {knex} [db=null] Database connection. If not given the host\n     *   Editor's database connection is used\n     * @returns {IValidator} Configured validation function\n     */\n    public static dbUnique(\n        cfg: ValidationOptions = null,\n        column: string = null,\n        table: string = null,\n        db: knex = null\n    ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            if ( db === null ) {\n                db = host.db;\n            }\n\n            if ( table === null ) {\n                table = host.editor.table()[0];\n            }\n\n            if ( column === null ) {\n                column = host.field.dbField();\n            }\n\n            let q = host.db()( table )\n                .select( column )\n                .where( { column: val } );\n\n            // If doing an edit then we need to also discount the current row,\n            // since it is of course already validly unique\n            if ( host.action === 'edit' ) {\n                let cond = host.editor.pkeyToObject( host.id, true );\n                q.whereNot( cond );\n            }\n\n            let res = await q;\n\n            return ! res ?\n                opts.message :\n                true;\n        };\n    }\n\n    /**\n     * Check that the given value is a value that is available in a database -\n     * i.e. a join primary key. This will attempt to automatically use the table\n     * name and value column from the field's `Options` method (under the\n     * assumption that it will typically be used with a joined field), but the\n     * table and field can also be specified via the options.\n     *\n     * @static\n     * @param {ValidationOptions} [cfg=null] Validation options\n     * @param {string} [column=null] Column name to use to check as a unique\n     *   value. If not given the host field's database column name is used\n     * @param {string} [table=null] Table to check that this value is uniquely\n     *   valid on. If not given the host Editor's table name is used\n     * @param {knex} [db=null] Database connection. If not given the host\n     *   Editor's database connection is used\n     * @returns {IValidator} Configured validation function\n     */\n    public static dbValues(\n        cfg: ValidationOptions = null,\n        column: string = null,\n        table: string = null,\n        db: knex = null\n    ): IValidator {\n        let opts = ValidationOptions.select( cfg );\n\n        return async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n            let common = Validator._common( val, opts );\n            let options = host.field.options();\n\n            if ( common !== null ) {\n                return common === false ?\n                    opts.message :\n                    true;\n            }\n\n            if ( db === null ) {\n                db = host.db;\n            }\n\n            if ( table === null && options instanceof JoinOptions ) {\n                table = options.table();\n            }\n\n            if ( column === null && options instanceof JoinOptions ) {\n                column = options.value();\n            }\n\n            if ( table === null || column === null ) {\n                throw new Error( 'Table or column for database value check is not ' +\n                    'defined for field ' + host.field.name()\n                );\n            }\n\n            let res = await db( table )\n                .select( column )\n                .where( { [column]: val } );\n\n            return ! res ?\n                opts.message :\n                true;\n        };\n    }\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    * File upload validators\n    */\n\n    /**\n     * Check that the uploaded file has a given extension\n     *\n     * @static\n     * @param {string[]} extns Allowed extensions\n     * @param {string} msg Error message to return if not valid\n     * @returns {IValidator} Configured validation function\n     */\n    public static fileExtensions( extns: string[], msg: string ): IFileValidator {\n        return async function( file: IFile ) {\n            return extns.includes( file.extn ) ?\n                true :\n                msg;\n        };\n    }\n\n    /**\n     * Check that the uploaded file is equal or less than a given size.\n     *\n     * @static\n     * @param {string[]} size Max file size in bytes\n     * @returns {IValidator} Configured validation function\n     */\n    public static fileSize( size: number, msg: string ): IFileValidator {\n        return async function( file: IFile ) {\n            return file.size > size ?\n                msg :\n                true;\n        };\n    }\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n    * Internal methods\n    */\n\n    private static _common( val: any, opts: ValidationOptions ): boolean|null {\n        // Error state tests\n        if ( !opts.optional && val === null ) {\n            // Value must be given\n            return false;\n        }\n\n        if ( val !== null && opts.empty === false && val === '' ) {\n            // Value must not be empty\n            return false;\n        }\n\n        // Validate passed states\n        if ( opts.optional && val === null ) {\n            return true;\n        }\n\n        if ( opts.empty === true && val === '' ) {\n            return true;\n        }\n\n        // Have the specific validation function perform its tests\n        return null;\n    }\n}\n"]}