{"version":3,"sources":["nestedData.ts"],"names":[],"mappings":"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","file":"nestedData.js","sourcesContent":["\n/**\n * Class that provides methods to read and write from nested JSON objects,\n * using dot notation strings for the nesting. This class should be extended\n * by any wishing to use these abilities.\n * @export\n * @class NestedData\n */\nexport default class NestedData {\n\t/**\n\t * @hidden\n\t * Check if a nested property exists in a data set.\n\t * @protected\n\t * @param {string} name Property name\n\t * @param {object} data Data set to check\n\t * @returns {boolean} `true` if present, `false` otherwise\n\t */\n\tprotected _propExists( name: string, data: object ): boolean {\n\t\tif (data === undefined) {\n\t\t  return false;\n\t\t}\n\t\tif ( name.indexOf('.') === -1 ) {\n\t\t\treturn data[ name ] === undefined ?\n\t\t\t\tfalse :\n\t\t\t\ttrue;\n\t\t}\n\n\t\tlet names = name.split('.');\n\t\tlet inner = data;\n\n\t\tfor ( let i = 0, ien = names.length - 1; i < ien; i++ ) {\n\t\t\tif ( inner[ names[i] ] === undefined ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tinner = inner[ names[i] ];\n\t\t}\n\n\t\treturn inner[ names[names.length - 1] ] === undefined ?\n\t\t\tfalse :\n\t\t\ttrue;\n\t}\n\n\t/**\n\t * @hidden\n\t * Get a nested property value.\n\t * @protected\n\t * @param {string} name Property name\n\t * @param {object} data Data set to check\n\t * @returns {*} Value\n\t */\n\tprotected _readProp( name: string, data: object ): any {\n\t\tif ( name.indexOf('.') === -1 ) {\n\t\t\treturn data[ name ] !== undefined ?\n\t\t\t\tdata[ name ] :\n\t\t\t\tnull;\n\t\t}\n\n\t\tlet names = name.split('.');\n\t\tlet inner = data;\n\n\t\tfor ( let i = 0, ien = names.length - 1; i < ien; i++ ) {\n\t\t\tif ( inner[ names[i] ] === undefined ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tinner = inner[ names[i] ];\n\t\t}\n\n\t\tlet idx = names[names.length - 1];\n\t\treturn inner[ idx ] !== undefined ?\n\t\t\tinner[ idx ] :\n\t\t\tnull;\n\t}\n\n\t/**\n\t * @hidden\n\t * Write a value to a nested data object.\n\t * @protected\n\t * @param {object} out Data object to write the value into\n\t * @param {string} name Nested property name to write to\n\t * @param {*} value Value to write\n\t * @returns {void} No return.\n\t */\n\tprotected _writeProp( out: object, name: string, value: any ): void {\n\t\tif ( name.indexOf('.') === -1 ) {\n\t\t\tout[ name ] = value;\n\t\t\treturn;\n\t\t}\n\n\t\tlet names = name.split('.');\n\t\tlet inner = out;\n\n\t\tfor ( let i = 0, ien = names.length - 1; i < ien; i++ ) {\n\t\t\tlet loopName = names[i];\n\n\t\t\tif ( inner[ loopName ] === undefined ) {\n\t\t\t\tinner[ loopName ] = {};\n\t\t\t}\n\t\t\telse if ( typeof inner[ loopName ] !== 'object' ) {\n\t\t\t\tthrow new Error('A property with the name `' + name + '` already exists. ' +\n\t\t\t\t\t'This can occur if you have properties which share a prefix - ' +\n\t\t\t\t\t'for example `name` and `name.first`.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tinner = inner[ loopName ];\n\t\t}\n\n\t\tlet idx = names[ names.length - 1 ];\n\n\t\tif ( inner[ idx ] !== undefined ) {\n\t\t\tthrow new Error( 'Duplicate field detected - a field with the name ' +\n\t\t\t\t'`' + name + '` already exists'\n\t\t\t);\n\t\t}\n\n\t\tinner[ idx ] = value;\n\t}\n}\n"]}