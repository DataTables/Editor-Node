{"version":3,"sources":["searchPaneOptions.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAM7B,MAAM,WAAW,OAAO;IACvB,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,GAAG,MAAM,CAAC;CACvB;AAED,oBAAY,SAAS,GAAG,CAAC,GAAG,EAAE,MAAM,KAAK,MAAM,CAAC;AAChD,oBAAY,aAAa,GAAG,CAAC,EAAE,EAAE,IAAI,KAAK,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;AAE7D;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,OAAO,OAAO,iBAAiB;IACrC,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,MAAM,CAAW;IACzB,OAAO,CAAC,SAAS,CAAuC;IACxD,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,SAAS,CAAY;IAC7B,OAAO,CAAC,MAAM,CAAM;IACpB,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,WAAW,CAAiB;IAMpC;;;;;OAKG;IAaH;;;;OAIG;IACI,KAAK,IAAI,MAAM,EAAE;IACxB;;;;;OAKG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,EAAE,GAAG,iBAAiB;IAahD;;;;OAIG;IACI,KAAK,IAAI,MAAM;IACtB;;;;;OAKG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,GAAG,iBAAiB;IAU9C;;;;OAIG;IACI,KAAK,IAAI,MAAM;IACtB;;;;;;;OAOG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,GAAG,iBAAiB;IAU9C;;;;OAIG;IACI,MAAM,IAAI,SAAS;IAC1B;;;;;;;OAOG;IACI,MAAM,CAAC,EAAE,EAAE,SAAS,GAAG,iBAAiB;IAU/C;;;;OAIG;IACI,KAAK,IAAI,MAAM;IACtB;;;;;OAKG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,GAAG,iBAAiB;IAU9C;;;;OAIG;IACI,KAAK,IAAI,MAAM;IACtB;;;;;;OAMG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,GAAG,iBAAiB;IAU9C;;;;OAIG;IACI,KAAK,IAAI,GAAG;IACnB;;;;;;OAMG;IACI,KAAK,CAAC,KAAK,EAAE,GAAG,GAAG,iBAAiB;IAUpC,QAAQ,CAAC,KAAK,KAAA,EAAE,MAAM,KAAA,EAAE,QAAQ,KAAA,EAAE,MAAM,KAAA,GAAG,IAAI;IActD;;OAEG;IACU,IAAI,CAAC,KAAK,KAAA,EAAE,MAAM,KAAA,EAAE,IAAI,KAAA,EAAE,QAAQ,KAAA,EAAE,UAAU,KAAA,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC;IAkKhF,OAAO,CAAC,QAAQ;IAYhB,OAAO,CAAC,eAAe;CAOvB","file":"searchPaneOptions.d.ts","sourcesContent":["import * as knex from 'knex';\n\nfunction isNumeric(n) {\n\treturn !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nexport interface IOption {\n\tlabel: string;\n\tvalue: string | number;\n}\n\nexport type IRenderer = (row: object) => string;\nexport type CustomOptions = (db: knex) => Promise<IOption[]>;\n\n/**\n * The Options class provides a convenient method of specifying where Editor\n * should get the list of options for a `select`, `radio` or `checkbox` field.\n * This is normally from a table that is _left joined_ to the main table being\n * edited, and a list of the values available from the joined table is shown to\n * the end user to let them select from.\n *\n * `Options` instances are used with the {@link Field.options} method.\n *\n * @export\n * @class Options\n */\nexport default class SearchPaneOptions {\n\tprivate _table: string;\n\tprivate _value: string;\n\tprivate _label: string[];\n\tprivate _leftJoin: Array<{[keys: string]: string}> = [];\n\tprivate _limit: number;\n\tprivate _renderer: IRenderer;\n\tprivate _where: any;\n\tprivate _order: string;\n\tprivate _manualOpts: IOption[] = [];\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Add extra options to the list, in addition to any obtained from the database\n\t *\n\t * @param label Label\n\t * @param value Value\n\t */\n\t// public add(label: string, value?: string) {\n\t// \tif (value === undefined) {\n\t// \t\tvalue = label;\n\t// \t}\n\t// \tthis._manualOpts.push({\n\t// \t\tlabel,\n\t// \t\tvalue\n\t// \t});\n\n\t// \treturn this;\n\t// }\n\n\t/**\n\t * Get the column(s) to be used for the label\n\t *\n\t * @returns {string[]} Label columns\n\t */\n\tpublic label(): string[];\n\t/**\n\t * Set the column(s) to be used for the label\n\t *\n\t * @param {string[]} label Database column names\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic label(label: string[]): SearchPaneOptions;\n\tpublic label(label?: string[]): any {\n\t\tif (label === undefined) {\n\t\t\treturn this._label;\n\t\t}\n\n\t\tthis._label = Array.isArray(label) ?\n\t\t\tlabel :\n\t\t\t[label];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the currently applied LIMIT\n\t *\n\t * @returns {number} Limit\n\t */\n\tpublic limit(): number;\n\t/**\n\t * Set the LIMIT clause to limit the number of records returned\n\t *\n\t * @param {number} limit Limit\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic limit(limit: number): SearchPaneOptions;\n\tpublic limit(limit?: number): any {\n\t\tif (limit === undefined) {\n\t\t\treturn this._limit;\n\t\t}\n\n\t\tthis._limit = limit;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the ORDER BY clause for the SQL.\n\t *\n\t * @returns {string} ORDER BY clause\n\t */\n\tpublic order(): string;\n\t/**\n\t * Set the ORDER BY clause to use in the SQL. If this option is not\n\t * provided the ordering will be based on the rendered output, either\n\t * numerically or alphabetically based on the data returned by the renderer.\n\t *\n\t * @param {string} order ORDER BY statement\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic order(order: string): SearchPaneOptions;\n\tpublic order(order?: string): any {\n\t\tif (order === undefined) {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tthis._order = order;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the configured label renderer\n\t *\n\t * @returns {IRenderer} Self for chaining\n\t */\n\tpublic render(): IRenderer;\n\t/**\n\t * Set the label renderer. The renderer can be used to combine\n\t * multiple database columns into a single string that is shown as the label\n\t * to the end user in the list of options.\n\t *\n\t * @param {IRenderer} fn Renderering function\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic render(fn: IRenderer): SearchPaneOptions;\n\tpublic render(fn?: IRenderer): any {\n\t\tif (fn === undefined) {\n\t\t\treturn this._renderer;\n\t\t}\n\n\t\tthis._renderer = fn;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the table that the options will be gathered from.\n\t *\n\t * @returns {string} Table name\n\t */\n\tpublic table(): string;\n\t/**\n\t * Set the database table from which to gather the options for the list.\n\t *\n\t * @param {string} table Table name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic table(table: string): SearchPaneOptions;\n\tpublic table(table?: string): any {\n\t\tif (table === undefined) {\n\t\t\treturn this._table;\n\t\t}\n\n\t\tthis._table = table;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the column name to use for the value in the options list.\n\t *\n\t * @returns {string} Column name\n\t */\n\tpublic value(): string;\n\t/**\n\t * Set the column name to use for the value in the options list. This would\n\t * normally be the primary key for the table.\n\t *\n\t * @param {string} value Column name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic value(value: string): SearchPaneOptions;\n\tpublic value(value?: string): any {\n\t\tif (value === undefined) {\n\t\t\treturn this._value;\n\t\t}\n\n\t\tthis._value = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the WHERE condition for this option set.\n\t *\n\t * @returns {*} Knex WHERE condition\n\t */\n\tpublic where(): any;\n\t/**\n\t * Set the method to use for a WHERE condition if one is to be applied to\n\t * the query to get the options.\n\t *\n\t * @param {*} where Knex WHERE condition\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic where(where: any): SearchPaneOptions;\n\tpublic where(where?: any): any {\n\t\tif (where === undefined) {\n\t\t\treturn this._where;\n\t\t}\n\n\t\tthis._where = where;\n\t\treturn this;\n\t}\n\n\tpublic leftJoin(table, field1, operator, field2): this {\n\t\tthis._leftJoin.push({\n\t\t\tfield1,\n\t\t\tfield2,\n\t\t\toperator,\n\t\t\ttable\n\t\t});\n\t\treturn this;\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t */\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async exec(field, editor, http, fieldsIn, leftJoinIn): Promise<IOption[]> {\n\t\tlet label;\n\t\tlet value;\n\t\tlet table;\n\t\tlet formatter = this._renderer;\n\t\tlet join = this._leftJoin;\n\t\tlet fields = fieldsIn;\n\n\t\tif (this._value === undefined) {\n\t\t\tvalue = field._spopts._label !== undefined ?\n\t\t\t\tfield._spopts._label[0] :\n\t\t\t\tvalue = field._name.split('.')[1];\n\t\t}\n\t\telse {\n\t\t\tvalue = this._value.indexOf('.') === -1 ?\n\t\t\t\tthis._value :\n\t\t\t\tthis._value.split('.')[1];\n\t\t}\n\n\t\tif (this._label === undefined) {\n\t\t\tlabel = value;\n\t\t}\n\t\telse {\n\t\t\tlabel = this._label[0].indexOf('.') === -1 ?\n\t\t\t\tthis._label :\n\t\t\t\tthis._label[0].split('.')[1];\n\t\t}\n\n\t\ttable = this._table === undefined ?\n\t\t\teditor._table[0] :\n\t\t\tthis._table;\n\n\t\tif (leftJoinIn !== undefined && leftJoinIn !== null) {\n\t\t\tjoin = leftJoinIn;\n\t\t}\n\n\t\tlet db = editor.db();\n\n\t\t// Create a list of the fields that we need to get from the db\n\t\t// let fields = [ value ].concat(label);\n\n\t\t// We need a default formatter if one isn't provided\n\t\tif (! formatter) {\n\t\t\tformatter = function(row) {\n\t\t\t\tlet a = [];\n\n\t\t\t\tfor (let i = 0, ien = label.length ; i < ien ; i++) {\n\t\t\t\t\ta.push(row[ label[i] ]);\n\t\t\t\t}\n\n\t\t\t\treturn a.join(' ');\n\t\t\t};\n\t\t}\n\n\t\tlet query = db\n\t\t\t.select(label + ' as label', value + ' as value')\n\t\t\t.count({count: '*'})\n\t\t\t.from(table)\n\t\t\t.distinct()\n\t\t\t.groupBy('value');\n\n\t\tif (http.searchPanes !== undefined) {\n\t\t\tfor (let fie of fields) {\n\t\t\t\tif (http.searchPanes[fie._name] !== undefined) {\n\t\t\t\t\tquery.where(function() {\n\t\t\t\t\t\tfor (let opt of http.searchPanes[fie._name]) {\n\t\t\t\t\t\t\tthis.orWhere(fie._name, opt);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get the data\n\t\tlet q = db\n\t\t\t.select(label + ' as label', value + ' as value')\n\t\t\t.count({total: '*'})\n\t\t\t.from(table)\n\t\t\t.distinct()\n\t\t\t.groupBy('value');\n\n\t\tif (this._where) {\n\t\t\tq.where(this._where);\n\t\t}\n\n\t\tif (join !== null && join !== undefined) {\n\t\t\tfor (let joiner of join) {\n\t\t\t\tq.leftJoin(joiner.table, joiner.field1, joiner.field2);\n\t\t\t\tquery.leftJoin(joiner.table, joiner.field1, joiner.field2);\n\t\t\t}\n\t\t}\n\n\t\tif (this._order) {\n\t\t\t// For cases where we are ordering by a field which isn't included in the list\n\t\t\t// of fields to display, we need to add the ordering field, due to the\n\t\t\t// select distinct.\n\t\t\tthis._order.split(',').forEach((val) => {\n\t\t\t\tlet fie = val.toLocaleLowerCase()\n\t\t\t\t\t.replace(' asc', '')\n\t\t\t\t\t.replace('desc', '')\n\t\t\t\t\t.trim();\n\n\t\t\t\tif (! fields.includes(fie)) {\n\t\t\t\t\tq.select(fie);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tq.orderBy(this._order);\n\t\t}\n\n\t\tif (this._limit) {\n\t\t\tq.limit(this.limit());\n\t\t}\n\n\t\tlet res = await q;\n\t\tlet cts = await query;\n\t\tlet out = [];\n\n\t\t// Create the output array\n\t\tfor (let recordCou of res) {\n\t\t\tlet set = false;\n\t\t\tfor (let recordTot of cts) {\n\t\t\t\tif (recordTot.value === recordCou.value) {\n\t\t\t\t\tout.push({\n\t\t\t\t\t\tcount: recordTot.count,\n\t\t\t\t\t\tlabel: recordCou.label,\n\t\t\t\t\t\ttotal: recordCou.total,\n\t\t\t\t\t\tvalue: recordCou.value\n\t\t\t\t\t});\n\t\t\t\t\tset = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!set) {\n\t\t\t\tout.push({\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tlabel: recordCou.label,\n\t\t\t\t\ttotal: recordCou.total,\n\t\t\t\t\tvalue: recordCou.value\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Stick on any extra manually added options\n\t\tif (this._manualOpts.length) {\n\t\t\tout = out.concat(this._manualOpts);\n\t\t}\n\n\t\t// Only sort if there was no SQL order field\n\t\tif (! this._order) {\n\t\t\tout.sort(function(a, b) {\n\t\t\t\tif (isNumeric(a) && isNumeric(b)) {\n\t\t\t\t\treturn (a.label * 1) - (b.label * 1);\n\t\t\t\t}\n\t\t\t\treturn a.label < b.label ?\n\t\t\t\t\t-1 : a.label > b.label ?\n\t\t\t\t\t\t1 :\n\t\t\t\t\t\t0;\n\t\t\t});\n\t\t}\n\t\treturn out;\n\t}\n\n\tprivate getWhere(query) {\n\t\tfor (let i = 0; i < this._where.length; i++) {\n\t\t\tif (typeof(this.where[i]) === 'function') {\n\t\t\t\tthis.where[i](query);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.where(query);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\tprivate performLeftJoin(query) {\n\t\tif (this._leftJoin.length > 0) {\n\t\t\tfor (let point of this._leftJoin) {\n\t\t\t\tlet join = point;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}