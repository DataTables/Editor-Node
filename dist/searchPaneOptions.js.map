{"version":3,"sources":["searchPaneOptions.ts"],"names":[],"mappings":"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","file":"searchPaneOptions.js","sourcesContent":["import * as knex from 'knex';\nimport Field from './field';\nimport Editor from './editor';\n\nfunction isNumeric(n) {\n\treturn !isNaN(parseFloat(n)) && isFinite(n);\n}\n\nexport interface IOption {\n\tlabel: string;\n\tvalue: string | number;\n}\n\nexport type IRenderer = (str: string) => string;\nexport type CustomOptions = (db: knex) => Promise<IOption[]>;\n\n/**\n * The Options class provides a convenient method of specifying where Editor\n * should get the list of options for a `select`, `radio` or `checkbox` field.\n * This is normally from a table that is _left joined_ to the main table being\n * edited, and a list of the values available from the joined table is shown to\n * the end user to let them select from.\n *\n * `Options` instances are used with the {@link Field.options} method.\n *\n * @export\n * @class Options\n */\nexport default class SearchPaneOptions {\n\tprivate _table: string;\n\tprivate _value: string;\n\tprivate _label: string[];\n\tprivate _leftJoin: Array<{[keys: string]: string}>;\n\tprivate _renderer: IRenderer;\n\tprivate _where: any;\n\tprivate _order: string;\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Get the column(s) to be used for the label\n\t *\n\t * @returns {string[]} Label columns\n\t */\n\tpublic label(): string[];\n\t/**\n\t * Set the column(s) to be used for the label\n\t *\n\t * @param {string[]} label Database column names\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic label(label: string[]): SearchPaneOptions;\n\tpublic label(label?: string[]): any {\n\t\tif (label === undefined) {\n\t\t\treturn this._label;\n\t\t}\n\n\t\tthis._label = Array.isArray(label) ?\n\t\t\tlabel :\n\t\t\t[label];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the ORDER BY clause for the SQL.\n\t *\n\t * @returns {string} ORDER BY clause\n\t */\n\tpublic order(): string;\n\t/**\n\t * Set the ORDER BY clause to use in the SQL. If this option is not\n\t * provided the ordering will be based on the rendered output, either\n\t * numerically or alphabetically based on the data returned by the renderer.\n\t *\n\t * @param {string} order ORDER BY statement\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic order(order: string): SearchPaneOptions;\n\tpublic order(order?: string): any {\n\t\tif (order === undefined) {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tthis._order = order;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the configured label renderer\n\t *\n\t * @returns {IRenderer} Self for chaining\n\t */\n\tpublic render(): IRenderer;\n\t/**\n\t * Set the label renderer. The renderer can be used to combine\n\t * multiple database columns into a single string that is shown as the label\n\t * to the end user in the list of options.\n\t *\n\t * @param {IRenderer} fn Renderering function\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic render(fn: IRenderer): SearchPaneOptions;\n\tpublic render(fn?: IRenderer): any {\n\t\tif (fn === undefined) {\n\t\t\treturn this._renderer;\n\t\t}\n\n\t\tthis._renderer = fn;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the table that the options will be gathered from.\n\t *\n\t * @returns {string} Table name\n\t */\n\tpublic table(): string;\n\t/**\n\t * Set the database table from which to gather the options for the list.\n\t *\n\t * @param {string} table Table name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic table(table: string): SearchPaneOptions;\n\tpublic table(table?: string): any {\n\t\tif (table === undefined) {\n\t\t\treturn this._table;\n\t\t}\n\n\t\tthis._table = table;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the column name to use for the value in the options list.\n\t *\n\t * @returns {string} Column name\n\t */\n\tpublic value(): string;\n\t/**\n\t * Set the column name to use for the value in the options list. This would\n\t * normally be the primary key for the table.\n\t *\n\t * @param {string} value Column name\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic value(value: string): SearchPaneOptions;\n\tpublic value(value?: string): any {\n\t\tif (value === undefined) {\n\t\t\treturn this._value;\n\t\t}\n\n\t\tthis._value = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the WHERE condition for this option set.\n\t *\n\t * @returns {*} Knex WHERE condition\n\t */\n\tpublic where(): any;\n\t/**\n\t * Set the method to use for a WHERE condition if one is to be applied to\n\t * the query to get the options.\n\t *\n\t * @param {*} where Knex WHERE condition\n\t * @returns {Options} Self for chaining\n\t */\n\tpublic where(where: any): SearchPaneOptions;\n\tpublic where(where?: any): any {\n\t\tif (where === undefined) {\n\t\t\treturn this._where;\n\t\t}\n\n\t\tthis._where = where;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the method to use for a leftJoin condition if one is to be applied\n\t * to the query to retrieve data from two tables\n\t *\n\t * @param table the table for the join\n\t * @param field1 the first field\n\t * @param operator operator for the join\n\t * @param field2 the second field\n\t */\n\tpublic leftJoin(table: string, field1: string, operator: string, field2: string): this {\n\t\tif(this._leftJoin === undefined || this._leftJoin === null) {\n\t\t\tthis._leftJoin = [];\n\t\t}\n\n\t\tthis._leftJoin.push({\n\t\t\tfield1,\n\t\t\tfield2,\n\t\t\toperator,\n\t\t\ttable\n\t\t});\n\t\treturn this;\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t */\n\n\t/**\n\t * Execution function for getting the SearchPane options\n\t * @param field The field to retrieve data from\n\t * @param editor The editor instance\n\t * @param http The http sent to the server\n\t * @param fieldsIn All of the fields\n\t * @param leftJoinIn Info for a leftJoin if required\n\t */\n\tpublic async exec(\n\t\tfield: Field, editor: Editor, http: any, fieldsIn: any, leftJoinIn: any\n\t): Promise<IOption[]> {\n\t\tlet label;\n\t\tlet value;\n\t\tlet table;\n\t\tlet formatter = this._renderer;\n\t\tlet join = this._leftJoin;\n\t\tlet fields = fieldsIn;\n\n\t\t// First get a value for `value`. This can be retrieved from either the\n\t\t//  SearchPaneOptions or the fieldName if it has not been declared\n\t\tif (this._value === undefined) {\n\t\t\tlet spopts = field.searchPaneOptions();\n\t\t\tvalue = spopts.label() !== undefined ?\n\t\t\t\tspopts.label()[0] :\n\t\t\t \tvalue = field.name();\n\t\t}\n\t\t// Otherwise we can just get it from the value that has been defined\n\t\telse {\n\t\t\tvalue = this._value;\n\t\t}\n\n\t\t// If label is undefined then just assume the same value as `value`\n\t\tif (this._label === undefined) {\n\t\t\tlabel = value;\n\t\t}\n\t\t// Otherwise work it out from what has been defined\n\t\telse {\n\t\t\tlabel = this._label;\n\t\t}\n\n\t\t// If the table has not been defined then get it from the editor instance\n\t\ttable = this._table !== undefined ?\n\t\t\tthis._table :\n\t\t\teditor.readTable().length > 0 ?\n\t\t\t\teditor.readTable()[0] :\n\t\t\t\teditor.table()[0];\n\n\t\tif (leftJoinIn !== undefined && leftJoinIn !== null && this._leftJoin === undefined) {\n\t\t\tjoin = leftJoinIn;\n\t\t}\n\n\t\tlet db = editor.db();\n\n\t\t// Create a list of the fields that we need to get from the db\n\t\t// let fields = [ value ].concat(label);\n\n\t\t// We need a default formatter if one isn't provided\n\t\tif (! formatter) {\n\t\t\tformatter = function(str) {\n\t\t\t\treturn str;\n\t\t\t};\n\t\t}\n\n\t\t// This query will get the count's according to any selections made in the SearchPanes\n\t\tlet query = db\n\t\t\t.select(label + ' as label', value + ' as value')\n\t\t\t.count({count: '*'})\n\t\t\t.from(table)\n\t\t\t.distinct()\n\t\t\t.groupBy(value);\n\n\t\t// This block applies all of the where conditions across the fields\n\t\t// Each field gets it's own where condition which must be satisfied\n\t\t// Each where condition can have multiple orWhere()s so that the or\n\t\t//  searching within the fields works.\n\t\tif (http.searchPanes !== undefined) {\n\t\t\tfor (let fie of fields) {\n\t\t\t\tif (http.searchPanes[fie.name()] !== undefined) {\n\t\t\t\t\tquery.where(function() {\n\t\t\t\t\t\tfor (let opt of http.searchPanes[fie.name()]) {\n\t\t\t\t\t\t\tthis.orWhere(fie.name(), opt);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// This query will get the total count for the field, assuming no filtering.\n\t\t// This is necessary for viewTotal and cascadePanes functionality\n\t\tlet q = db\n\t\t\t.select(label + ' as label', value + ' as value')\n\t\t\t.count({total: '*'})\n\t\t\t.from(table)\n\t\t\t.distinct()\n\t\t\t.groupBy(value);\n\n\t\tif (this._where) {\n\t\t\tq.where(this._where);\n\t\t}\n\n\t\t// If a left join needs to be done for the above queries we can just do it in the same place\n\t\tif (join !== null && join !== undefined) {\n\t\t\tfor (let joiner of join) {\n\t\t\t\tq.leftJoin(joiner.table, joiner.field1, joiner.field2);\n\t\t\t\tquery.leftJoin(joiner.table, joiner.field1, joiner.field2);\n\t\t\t}\n\t\t}\n\n\t\tif (this._order) {\n\t\t\t// For cases where we are ordering by a field which isn't included in the list\n\t\t\t// of fields to display, we need to add the ordering field, due to the\n\t\t\t// select distinct.\n\t\t\tthis._order.split(',').forEach((val) => {\n\t\t\t\tlet fie = val.toLocaleLowerCase()\n\t\t\t\t\t.replace(' asc', '')\n\t\t\t\t\t.replace('desc', '')\n\t\t\t\t\t.trim();\n\n\t\t\t\tif (! fields.includes(fie)) {\n\t\t\t\t\tq.select(fie);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tq.orderBy(this._order);\n\t\t}\n\n\t\tlet res = await q;\n\t\tlet cts = await query;\n\t\tlet out = [];\n\n\t\t// Create the output array and add the values of count, label, total and value for each unique entry\n\t\tfor (let recordCou of res) {\n\t\t\tlet set = false;\n\n\t\t\tfor (let recordTot of cts) {\n\t\t\t\tif (recordTot.value === recordCou.value) {\n\t\t\t\t\tout.push({\n\t\t\t\t\t\tcount: recordTot.count,\n\t\t\t\t\t\tlabel: formatter(recordCou.label),\n\t\t\t\t\t\ttotal: recordCou.total,\n\t\t\t\t\t\tvalue: recordCou.value\n\t\t\t\t\t});\n\t\t\t\t\tset = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the values are not found then the count is 0 according to `query` so add it anyway but with that value\n\t\t\tif (!set) {\n\t\t\t\tout.push({\n\t\t\t\t\tcount: 0,\n\t\t\t\t\tlabel: formatter(recordCou.label),\n\t\t\t\t\ttotal: recordCou.total,\n\t\t\t\t\tvalue: recordCou.value\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// Only sort if there was no SQL order field\n\t\tif (! this._order) {\n\t\t\tout.sort(function(a, b) {\n\t\t\t\tif (isNumeric(a) && isNumeric(b)) {\n\t\t\t\t\treturn (a.label * 1) - (b.label * 1);\n\t\t\t\t}\n\t\t\t\treturn a.label < b.label ?\n\t\t\t\t\t-1 : a.label > b.label ?\n\t\t\t\t\t\t1 :\n\t\t\t\t\t\t0;\n\t\t\t});\n\t\t}\n\t\treturn out;\n\t}\n}\n"]}