{"version":3,"sources":["upload.ts"],"names":[],"mappings":"AAIA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAG7B,OAAO,MAAM,MAAM,UAAU,CAAC;AAC9B,OAAO,KAAK,MAAM,SAAS,CAAC;AAO5B,oBAAY,MAAM;IACjB,OAAO,IAAA;IACP,WAAW,IAAA;IACX,IAAI,IAAA;IACJ,IAAI,IAAA;IACJ,QAAQ,IAAA;IACR,QAAQ,IAAA;IACR,QAAQ,IAAA;IACR,QAAQ,IAAA;IACR,UAAU,IAAA;CAIV;AAED,MAAM,WAAW,KAAK;IACrB,IAAI,EAAE,MAAM,CAAC;IACb,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,EAAE,MAAM,CAAC;IACjB,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,OAAO,CAAC;IACnB,IAAI,EAAE,OAAO,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,MAAM,CAAC;IACb,IAAI,EAAE,MAAM,CAAC;CACb;AAED,MAAM,WAAW,OAAO;IACvB,MAAM,EAAE,KAAK,CAAC;CACd;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AACH,MAAM,CAAC,OAAO,OAAO,MAAM;IAC1B,OAAc,EAAE,gBAAU;IAC1B,OAAc,MAAM,gBAAU;IAE9B,OAAO,CAAC,OAAO,CAAkB;IACjC,OAAO,CAAC,gBAAgB,CAAC;IACzB,OAAO,CAAC,kBAAkB,CAAS;IACnC,OAAO,CAAC,QAAQ,CAAS;IACzB,OAAO,CAAC,OAAO,CAAS;IACxB,OAAO,CAAC,SAAS,CAAC;IAClB,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,WAAW,CAAM;IACzB,OAAO,CAAC,MAAM,CAAM;gBAMP,MAAM,GAAE,MAAM,GAAC,QAAe;IAU3C;;;;;;;;;;;;;;;;;OAiBG;IACI,MAAM,CAAE,MAAM,EAAE,MAAM,GAAC,QAAQ,GAAI,MAAM;IAMhD;;;;;;;;;;;;;;;;;OAiBG;IACI,EAAE,CAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAI,MAAM;IAQhE;;;;;;;;;;;OAWG;IACI,OAAO,CAAE,UAAU,EAAE,MAAM,GAAC,QAAQ,EAAE,QAAQ,GAAE,QAAe,GAAI,MAAM;IAchF;;;;;;;;;OASG;IACI,SAAS,CAAE,EAAE,KAAA,GAAI,MAAM;IAM9B;;;;;;;;OAQG;IACI,KAAK,CAAE,EAAE,KAAA,GAAI,MAAM;IAU1B;;OAEG;IACU,IAAI,CAAE,EAAE,EAAE,IAAI,EAAE,GAAG,GAAE,MAAM,EAAS,GAAI,OAAO,CAAC,MAAM,CAAC;IAqCpE;;OAEG;IACU,WAAW,CAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,GAAI,OAAO,CAAC,IAAI,CAAC;IAOvE;;OAEG;IACI,KAAK;IAIZ;;OAEG;IACU,IAAI,CAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,GAAI,OAAO,CAAE,MAAM,CAAC;IAgDtE;;OAEG;IACI,IAAI;IAIX;;OAEG;IACI,KAAK;YAOE,WAAW;YAuBX,QAAQ;YA4ER,OAAO;IA8FrB,OAAO,CAAC,WAAW;CAcnB","file":"upload.d.ts","sourcesContent":["import * as fs from 'fs';\nimport * as path from 'path';\n\nimport * as rootPath from 'app-root-path';\nimport * as knex from 'knex';\nimport * as mv from 'mv';\n\nimport Editor from './editor';\nimport Field from './field';\nimport promisify from './promisify';\n\nlet stat = promisify( fs.stat );\nlet readFile = promisify( fs.readFile );\nlet rename = promisify( mv );\n\nexport enum DbOpts {\n\tContent,\n\tContentType,\n\tExtn,\n\tName,\n\tFileName, // Name + Extn\n\tFileSize,\n\tMimeType,\n\tReadOnly,\n\tSystemPath\n\t// Note that the PHP and .NET libraries have a WebPath, but that isn't\n\t// available here as there isn't a good and reliable way to get the web\n\t// root in node (it could be anywhere!).\n}\n\nexport interface IFile {\n\tuuid: string;\n\tfield: string;\n\tfile: string; // full path\n\tfilename: string; // name + extn\n\tencoding: string;\n\tmimetype: string;\n\ttruncated: boolean;\n\tdone: boolean;\n\tsize: number; // Added\n\textn: string; // Added\n\tname: string; // Added\n}\n\nexport interface IUpload {\n\tupload: IFile;\n}\n\n/**\n * Upload class for Editor. This class provides the ability to easily specify\n * file upload information, specifically how the file should be recorded on\n * the server (database and file system).\n *\n * An instance of this class is attached to a field using the {@link\n * Field.upload} method. When Editor detects a file upload for that file the\n * information provided for this instance is executed.\n *\n * The configuration is primarily driven through the {@link db} and {@link\n * action} methods:\n *\n * * {@link db} Describes how information about the uploaded file is to be\n *   stored on the database.\n * * {@link action} Describes where the file should be stored on the file system\n *   and provides the option of specifying a custom action when a file is\n *   uploaded.\n *\n * Both methods are optional - you can store the file on the server using the\n * {@link db} method only if you want to store the file in the database, or if\n * you don't want to store relational data on the database us only {@link\n * action}. However, the majority of the time it is best to use both - store\n * information about the file on the database for fast retrieval (using a {@link\n * Editor.leftJoin()} for example) and the file on the file system for direct\n * web access.\n *\n * @export\n * @class Upload\n */\nexport default class Upload {\n\tpublic static Db = DbOpts; // legacy\n\tpublic static DbOpts = DbOpts;\n\n\tprivate _action: string|Function;\n\tprivate _dbCleanCallback; // async function\n\tprivate _dbCleanTableField: string;\n\tprivate _dbTable: string;\n\tprivate _dbPkey: string;\n\tprivate _dbFields;\n\tprivate _error: string;\n\tprivate _validators = [];\n\tprivate _where = [];\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\tconstructor( action: string|Function = null ) {\n\t\tif ( action ) {\n\t\t\tthis.action( action );\n\t\t}\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Set the action to take when a file is uploaded. This can be either of:\n\t *\n\t * * A string - the value given is the full system path to where the\n\t *   uploaded file is written to. The value given can include three \"macros\"\n\t *   which are replaced by the script dependent on the uploaded file:\n\t *   * `__EXTN__` - the file extension\n\t *   * `__NAME__` - the uploaded file's name (including the extension)\n\t *   * `__ID__` - Database primary key value if the {@link db} method is\n\t *     used.\n\t * * A closure - if a function is given the responsibility of what to do\n\t *   with the uploaded file is transferred to this function. That will\n\t *   typically involve writing it to the file system so it can be used\n\t *   later.\n\t *\n\t * @param {(string|Function)} action Upload action\n\t * @returns {Upload} Self for chaining\n\t */\n\tpublic action( action: string|Function ): Upload {\n\t\tthis._action = action;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Database configuration method. When used, this method will tell Editor\n\t * what information you want written to a database on file upload, should\n\t * you wish to store relational information about your file on the database\n\t * (this is generally recommended).\n\t *\n\t * @param {string} table The name of the table where the file information\n\t *     should be stored\n\t * @param {string} pkey Primary key column name. The `Upload` class\n\t *     requires that the database table have a single primary key so each\n\t *     row can be uniquely identified.\n\t * @param {object} fields A list of the fields to be written to on upload.\n\t *     The property names are the database columns and the values can be\n\t *     defined by the constants of this class. The value can also be a\n\t *     string or a closure function if you wish to send custom information\n\t *     to the database.\n\t * @returns {Upload} Self for chaining\n\t */\n\tpublic db( table: string, pkey: string, fields: object ): Upload {\n\t\tthis._dbTable = table;\n\t\tthis._dbPkey = pkey;\n\t\tthis._dbFields = fields;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a callback function that is used to remove files which no longer have\n\t * a reference in a source table.\n\t *\n\t * @param {(string|Function)} tableField Table field to be used for the delete match\n\t * @param {Function} [callback=null] Function that will be executed on clean. It is\n\t *   given an array of information from the database about the orphaned\n\t *   rows, and can return true to indicate that the rows should be\n\t *   removed from the database. Any other return value (including none)\n\t *   will result in the records being retained.\n\t * @returns {Upload} Self for chaining\n\t */\n\tpublic dbClean( tableField: string|Function, callback: Function = null ): Upload {\n\t\t// Argument swapping\n\t\tif ( typeof tableField === 'function' ) {\n\t\t\tthis._dbCleanTableField = null;\n\t\t\tthis._dbCleanCallback = tableField;\n\t\t}\n\t\telse {\n\t\t\tthis._dbCleanTableField = tableField;\n\t\t\tthis._dbCleanCallback = callback;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a validation method to check file uploads. Multiple validators can be\n\t * added by calling this method multiple times - they will be executed in\n\t * sequence when a file has been uploaded.\n\t *\n\t * @param {any} fn Validation function. A files parameter is\n\t *   passed in for the uploaded file and the return is either a string\n\t *   (validation failed and error message), or `true` (validation passed).\n\t * @returns {Upload} Self for chaining\n\t */\n\tpublic validator( fn ): Upload {\n\t\tthis._validators.push( fn );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a condition to the data to be retrieved from the database. This\n\t * must be given as a function to be executed (usually anonymous) and\n\t * will be passed in a single argument, the `Query` object, to which\n\t * conditions can be added. Multiple calls to this method can be made.\n\t *\n\t * @param {any} fn Knex WHERE condition\n\t * @returns {Upload} Self for chaining\n\t */\n\tpublic where( fn ): Upload {\n\t\tthis._where.push( fn );\n\n\t\treturn this;\n\t}\n\n\t/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\t * Internal methods\n\t */\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async data( db: knex, ids: string[] = null ): Promise<object> {\n\t\tif ( ! this._dbTable ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Select the details requested, for the columns requested\n\t\tlet query = db\n\t\t\t.select( this._dbPkey )\n\t\t\t.from( this._dbTable );\n\n\t\tlet keys = Object.keys( this._dbFields );\n\t\tfor ( let i = 0, ien = keys.length ; i < ien ; i++ ) {\n\t\t\tlet key = keys[i];\n\n\t\t\tif ( this._dbFields[ key ] !== DbOpts.Content ) {\n\t\t\t\tquery.select( key );\n\t\t\t}\n\t\t}\n\n\t\tif ( ids !== null ) {\n\t\t\tquery.whereIn( this._dbPkey, ids );\n\t\t}\n\n\t\tfor ( let i = 0, ien = this._where.length ; i < ien ; i++ ) {\n\t\t\tquery.where( this._where[i] );\n\t\t}\n\n\t\tlet result = await query;\n\t\tlet out = {};\n\n\t\tfor ( let i = 0, ien = result.length ; i < ien ; i++ ) {\n\t\t\tout[ result[i][ this._dbPkey] ] = result[i];\n\t\t}\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async dbCleanExec( editor: Editor, field: Field ): Promise<void> {\n\t\t// Database and file system clean up BEFORE adding the new file to\n\t\t// the db, otherwise it will be removed immediately\n\t\tlet tables = editor.table();\n\t\tthis._dbClean( editor.db(), tables[0], field.dbField() );\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic error() {\n\t\treturn this._error;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async exec( editor: Editor, upload: IUpload ): Promise <string> {\n\t\tlet id;\n\n\t\t// Add any extra information to the upload structure\n\t\tlet fileInfo = await stat( upload.upload.file );\n\t\tupload.upload.size = fileInfo.size;\n\n\t\tlet a = upload.upload.filename.split('.');\n\t\tupload.upload.extn = a.length > 1 ?\n\t\t\ta.pop() :\n\t\t\t'';\n\t\tupload.upload.name = a.join('.');\n\n\t\t// Validation\n\t\tfor ( let i = 0, ien = this._validators.length ; i < ien ; i++ ) {\n\t\t\tlet result = await this._validators[i]( upload.upload );\n\n\t\t\tif ( typeof result === 'string' ) {\n\t\t\t\tthis._error = result;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// Database\n\t\tif ( this._dbTable ) {\n\t\t\tlet fields = Object.keys( this._dbFields );\n\n\t\t\tfor ( let i = 0, ien = fields.length ; i < ien ; i++ ) {\n\t\t\t\tlet prop = this._dbFields[ fields[i] ];\n\n\t\t\t\t// We can't know what the path is, if it has moved into place\n\t\t\t\t// by an external function - throw an error if this does happen\n\t\t\t\tif ( typeof this._action !== 'string' && prop === DbOpts.SystemPath ) {\n\t\t\t\t\tthis._error = 'Cannot set path information in the database ' +\n\t\t\t\t\t\t'if a custom method is used to save the file.';\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Commit to the database\n\t\t\tid = await this._dbExec( editor.db(), upload );\n\t\t}\n\n\t\tlet res = await this._actionExec( id, upload );\n\t\treturn res;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic pkey() {\n\t\treturn this._dbPkey;\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic table() {\n\t\treturn this._dbTable;\n\t}\n\n\t/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *\n\t * Private methods\n\t */\n\tprivate async _actionExec( id: string, files: IUpload ): Promise<string> {\n\t\tif ( typeof this._action === 'function' ) {\n\t\t\tlet res = await this._action( files.upload, id );\n\t\t\treturn res;\n\t\t}\n\n\t\t// Default action - move the file to the location specified by the\n\t\t// action string\n\t\tlet to = this._substitute( this._action, files.upload.file, id );\n\t\tto = path.normalize( to );\n\n\t\ttry {\n\t\t\tawait( rename( files.upload.file, to, {mkdirp: true} ) );\n\t\t} catch (e) {\n\t\t\tthis._error = 'An error occurred while moving the uploaded file.';\n\t\t\treturn null;\n\t\t}\n\n\t\treturn id !== null ?\n\t\t\tid :\n\t\t\tto;\n\t}\n\n\tprivate async _dbClean( db: knex, editorTable: string, fieldName: string ): Promise<void> {\n\t\tlet callback = this._dbCleanCallback;\n\t\tlet that = this;\n\n\t\tif ( ! this._dbTable || ! callback ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is a table / field that we should use to check if the value\n\t\t// is in use, then use that. Otherwise we'll try to use the information\n\t\t// from the Editor / Field instance.\n\t\tif ( this._dbCleanTableField ) {\n\t\t\tfieldName = this._dbCleanTableField;\n\t\t}\n\n\t\tlet table;\n\t\tlet field;\n\t\tlet a = fieldName.split('.');\n\n\t\tif ( a.length === 1 ) {\n\t\t\ttable = editorTable;\n\t\t\tfield = a[0];\n\t\t}\n\t\telse if ( a.length === 2 ) {\n\t\t\ttable = a[0];\n\t\t\tfield = a[1];\n\t\t}\n\t\telse {\n\t\t\ttable = a[1];\n\t\t\tfield = a[2];\n\t\t}\n\n\t\t// Select the details requested, for the columns requested\n\t\tlet fields = this._dbFields;\n\t\tlet columns = Object.keys( fields );\n\t\tlet query = db\n\t\t\t.select( this._dbPkey )\n\t\t\t.from( this._dbTable );\n\n\t\tfor ( let i = 0, ien = columns.length ; i < ien ; i++ ) {\n\t\t\tlet column = columns[i];\n\t\t\tlet prop = fields[ column ];\n\n\t\t\tif ( prop !== DbOpts.Content ) {\n\t\t\t\tquery.select( column );\n\t\t\t}\n\t\t}\n\n\t\tquery.whereNotIn( this._dbPkey, function() {\n\t\t\tthis.select( field ).from( table ).whereNotNull( field );\n\t\t} );\n\n\t\tlet rows = await query;\n\n\t\tif ( rows.length === 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet result = await callback( rows );\n\n\t\t// Delete the selected rows, iff the developer says to do so with the\n\t\t// returned value (i.e. acknowledge that the files have be removed from\n\t\t// the file system)\n\t\tif ( result === true ) {\n\t\t\tlet queryDel = db\n\t\t\t\t.from( this._dbTable )\n\t\t\t\t.where( function() {\n\t\t\t\t\tfor ( let i = 0, ien = rows.length ; i < ien ; i++ ) {\n\t\t\t\t\t\tthis.orWhere( { [that._dbPkey]: rows[i][that._dbPkey] } );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\tawait queryDel.del();\n\t\t}\n\t}\n\n\tprivate async _dbExec( db: knex, files: IUpload ): Promise<string> {\n\t\tlet pathFields = {};\n\t\tlet fields = this._dbFields;\n\t\tlet columns = Object.keys( fields );\n\t\tlet set = {};\n\t\tlet upload = files.upload;\n\n\t\tfor ( let i = 0, ien = columns.length ; i < ien ; i++ ) {\n\t\t\tlet column = columns[i];\n\t\t\tlet prop = fields[ column ];\n\n\t\t\tswitch ( prop ) {\n\t\t\t\tcase DbOpts.ReadOnly:\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DbOpts.Content:\n\t\t\t\t\tset[ column ] = await readFile( upload.file );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DbOpts.ContentType:\n\t\t\t\tcase DbOpts.MimeType:\n\t\t\t\t\tset[ column ] = upload.mimetype;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DbOpts.Extn:\n\t\t\t\t\tset[ column ] = upload.extn;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DbOpts.FileName:\n\t\t\t\t\tset[ column ] = upload.filename;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DbOpts.Name:\n\t\t\t\t\tset[ column ] = upload.name;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DbOpts.FileSize:\n\t\t\t\t\tset[ column ] = upload.size;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase DbOpts.SystemPath:\n\t\t\t\t\tpathFields[ column ] = this._action;\n\t\t\t\t\tset[ column ] = '-'; // Use a temporary value to avoid cases\n\t\t\t\t\tbreak;               // where the db will reject empty values\n\n\t\t\t\tdefault:\n\t\t\t\t\tlet val = typeof prop === 'function' ?\n\t\t\t\t\t\tprop( db, upload ) :\n\t\t\t\t\t\tprop;\n\n\t\t\t\t\tif ( typeof val === 'string' && val.match(/\\{.*\\}/) ) {\n\t\t\t\t\t\tpathFields[ column ] = val;\n\t\t\t\t\t\tset[ column ] = '-';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tset[ column ] = val;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet res = await db\n\t\t\t.insert( set )\n\t\t\t.from( this._dbTable )\n\t\t\t.returning( this._dbPkey );\n\n\t\tlet id = res[0];\n\n\t\t// Update the newly inserted row with the path information. We have to\n\t\t// use a second statement here as we don't know in advance what the\n\t\t// database schema is and don't want to prescribe that certain triggers\n\t\t// etc be created. It makes it a bit less efficient but much more\n\t\t// compatible\n\t\tlet pathKeys = Object.keys( pathFields );\n\n\t\tif ( pathKeys.length ) {\n\t\t\t// For this to operate the action must be a string, which is\n\t\t\t// validated in the `exec` method\n\t\t\tlet toSet = {};\n\n\t\t\tfor ( let i = 0, ien = pathKeys.length ; i < ien ; i++ ) {\n\t\t\t\tlet key = pathKeys[i];\n\t\t\t\ttoSet[ key ] = this._substitute( pathFields[key], upload.file, id );\n\t\t\t}\n\n\t\t\tawait db\n\t\t\t\t.update( toSet )\n\t\t\t\t.from( this._dbTable )\n\t\t\t\t.where( { [this._dbPkey]: id } );\n\t\t}\n\n\t\treturn id;\n\t}\n\n\tprivate _substitute( convert: string, uploadPath: string, id: string ): string {\n\t\tlet a = uploadPath.toString().split( '/' );\n\t\tlet fileName = a.pop();\n\t\tlet fileParts = fileName.split('.');\n\t\tlet extn = fileParts.pop();\n\t\tlet namePart = fileParts.join('.');\n\n\t\tlet to = convert.toString();\n\t\tto = to.replace( '{name}', namePart );\n\t\tto = to.replace( '{id}', id );\n\t\tto = to.replace( '{extn}', extn );\n\n\t\treturn to;\n\t}\n}\n"]}