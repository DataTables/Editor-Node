{"version":3,"sources":["promisify.ts"],"names":[],"mappings":"AACA;;;;;;;;;GASG;AACH,MAAM,CAAC,OAAO,UAAU,SAAS,CAAC,CAAC,EAAG,EAAE,EAAE,QAAQ,EAAE,KAAK,GAAE,GAAU,GAAI,QAAQ,CAiBhF","file":"promisify.d.ts","sourcesContent":["\n/**\n * Wrap an async function which uses a callback for completion in a Promise\n * so it can be used with `await`.\n *\n * @export\n * @template T Return type\n * @param {Function} fn Function to execute\n * @param {*} [scope=null] Scope\n * @returns {Function} Promise wrapper function\n */\nexport default function promisify<T>( fn: Function, scope: any = null ): Function {\n\treturn function(...args): Promise<T> {\n\t\treturn new Promise<T>( function( resolve: Function, reject: Function ) {\n\t\t\t// Assume the callback handler goes at the end of the arguments\n\t\t\targs.push( function( err: object, val: any ) {\n\t\t\t\t// Assume that err is the first argument and value is the second\n\t\t\t\tif ( err ) {\n\t\t\t\t\treject( err );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve( val );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tfn.apply( scope || fn, args );\n\t\t} );\n\t};\n}\n"]}