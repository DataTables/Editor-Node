{"version":3,"sources":["field.ts"],"names":[],"mappings":"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","file":"field.js","sourcesContent":["import knex from 'knex';\n\nimport Editor from './editor';\nimport {IFormatter} from './formatters';\nimport NestedData from './nestedData';\nimport Options, {CustomOptions, IOption} from './options';\nimport Upload from './upload';\nimport Validator, {IValidator} from './validators';\nimport xss, {Ixss} from './xss';\n\n/**\n * Set types\n * @export\n */\nexport enum SetType {\n    /** Do not set data */\n    None,\n\n    /** Write to database on both create and edit */\n    Both,\n\n    /** Write to the database only on create */\n    Create,\n\n    /** Write to the database only on edit */\n    Edit\n}\n\n/**\n * Field definitions for the DataTables Editor.\n *\n * Each Database column that is used with Editor can be described with this\n * Field method (both for Editor and Join instances). It basically tells\n * Editor what table column to use, how to format the data and if you want\n * to read and/or write this column.\n *\n * Field instances are used with the {@link Editor.field} and\n * {@link Mjoin.field} methods to describe what fields should be interacted\n * with by the editable table.\n *\n * @export\n * @class Field\n * @extends {NestedData}\n */\nexport default class Field extends NestedData {\n    public static SetType = SetType;\n\n    private _dbField: string;\n    private _get: boolean = true;\n    private _getFormatter: IFormatter;\n    private _getValue: any;\n    private _opts: Options & CustomOptions;\n    private _name: string;\n    private _set: SetType = SetType.Both;\n    private _setFormatter: IFormatter;\n    private _setValue: any;\n    private _validator: IValidator[] = [];\n    private _upload: Upload;\n    private _xss: Ixss;\n    private _xssFormat: boolean = true;\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n    /**\n     * Creates an instance of Field.\n     *\n     * @param {string} [dbField=null] Name of the database column\n     * @param {string} [name=null] Name to use in the JSON output from Editor and the\n     *   HTTP submit from the client-side when editing. If not given then the\n     *   `dbField` name is used.\n     */\n    constructor( dbField: string = null, name: string = null ) {\n        super();\n\n        if ( ! name && dbField ) {\n            // Standard usage, a single parameter\n            this\n                .name( dbField )\n                .dbField( dbField );\n        }\n        else {\n            this\n                .name( name )\n                .dbField( dbField );\n        }\n    }\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n    /**\n     * Get the database column name\n     *\n     * @returns {string} Configured column name\n     */\n    public dbField(): string;\n    /**\n     * Set the database column name\n     *\n     * @param {string} dbField Column name to set\n     * @returns {Field} Self for chaining\n     */\n    public dbField(dbField: string): Field;\n    public dbField(dbField?: string): any {\n        if ( dbField === undefined ) {\n            return this._dbField;\n        }\n\n        this._dbField = dbField;\n        return this;\n    }\n\n    /**\n     * Get the `get` flag for the field (i.e. if the field should be\n     * read from the database).\n     *\n     * @returns {boolean} True if gettable, false otherwise.\n     */\n    public get(): boolean;\n    /**\n     * Set the `get` flag.\n     *\n     * @param {boolean} flag `true` to mark as readable, false otherwise\n     * @returns {Field} Self for chaining\n     */\n    public get(flag: boolean): Field;\n    public get(flag?: boolean): any {\n        if ( flag === undefined ) {\n            return this._get;\n        }\n\n        this._get = flag;\n        return this;\n    }\n\n    /**\n     * Get formatter for the field's data.\n     *\n     * @returns {IFormatter} Formatter\n     */\n    public getFormatter(): IFormatter;\n    /**\n     * Set the get formatter.\n     *\n     * When the data has been retrieved from the server, it can be passed through\n     * a formatter here, which will manipulate (format) the data as required. This\n     * can be useful when, for example, working with dates and a particular format\n     * is required on the client-side.\n     *\n     * @param {IFormatter} formatter Formatter to use.\n     * @returns {Field} Self for chaining.\n     */\n    public getFormatter(formatter: IFormatter): Field;\n    public getFormatter(formatter?: IFormatter): any {\n        if ( formatter === undefined ) {\n            return this._getFormatter;\n        }\n\n        this._getFormatter = formatter;\n        return this;\n    }\n\n    /**\n     * Get the currently applied get value.\n     *\n     * @returns {*} Value - will be undefined by default.\n     */\n    public getValue(): any;\n    /**\n     * Set the get value for the field.\n     *\n     * If given, then this value is used to send to the client-side, regardless\n     * of what value is held by the database.\n     *\n     * @param {*} val Value to set\n     * @returns {Field} Self for chaining\n     */\n    public getValue(val: any): Field;\n    public getValue(val?: any): any {\n        if ( val === undefined ) {\n            return this._getValue;\n        }\n\n        this._getValue = val;\n        return this;\n    }\n\n    /**\n     * Get the field's configured name.\n     *\n     * @returns {string} Current name.\n     */\n    public name(): string;\n    /**\n     * Set the field's name.\n     *\n     * The name is typically the same as the dbField name, since it makes things\n     * less confusing(!), but it is possible to set a different name for the data\n     * which is used in the JSON returned to DataTables in a 'get' operation and\n     * the field name used in a 'set' operation.\n     *\n     * @param {string} name Name to set\n     * @returns {Field} Self for chaining\n     */\n    public name(name: string): Field;\n    public name(name?: string): any {\n        if ( name === undefined ) {\n            return this._name;\n        }\n\n        this._name = name;\n        return this;\n    }\n\n    /**\n     * Get the currently configured options for the field.\n     *\n     * @returns {(Options & CustomOptions)} Options configuration\n     */\n    public options(): Options & CustomOptions;\n    /**\n     * Set how a list of options (values and labels) will be retrieved for the field.\n     *\n     * Gets a list of values that can be used for the options list in radio,\n     * select and checkbox inputs from the database for this field.\n     *\n     * Note that this is for simple 'label / value' pairs only. For more complex\n     * data, including pairs that require joins and where conditions, use a\n     * closure to provide a query\n     *\n     * @param {(Options & CustomOptions)} opts Options configuration\n     * @returns {Field} Self for chaining\n     */\n    public options(opts: Options & CustomOptions): Field;\n    public options(opts?: Options & CustomOptions): any {\n        if ( opts === undefined ) {\n            return this._opts;\n        }\n\n        this._opts = opts;\n        return this;\n    }\n\n    /**\n     * Get the current `set` property for the field.\n     *\n     * @returns {SetType} Set configuration\n     */\n    public set(): SetType;\n    /**\n     * Set the field's `set` configuration.\n     *\n     * A field can be marked as read only using this option, to be set only\n     * during an create or edit action or to be set during both actions. This\n     * provides the ability to have fields that are only set when a new row is\n     * created (for example a \"created\" time stamp).\n     *\n     * @param {(boolean|SetType)} flag Set flag.\n     * @returns {Field} Self for chaining.\n     */\n    public set(flag: boolean|SetType): Field;\n    public set(flag?: boolean): any {\n        if ( flag === undefined ) {\n            return this._set;\n        }\n\n        if ( flag === true ) {\n            this._set = SetType.Both;\n        }\n        else if ( flag === false ) {\n            this._set = SetType.None;\n        }\n        else {\n            this._set = flag;\n        }\n\n        return this;\n    }\n\n    /**\n     * Set formatter for the field's data.\n     *\n     * @returns {IFormatter} Formatter\n     */\n    public setFormatter(): IFormatter;\n    /**\n     * Set the set formatter.\n     *\n     * When the data has been retrieved from the server, it can be passed through\n     * a formatter here, which will manipulate (format) the data as required. This\n     * can be useful when, for example, working with dates and a particular format\n     * is required on the client-side.\n     *\n     * Editor has a number of formatters available with the {@link Format} class\n     * which can be used directly with this method.\n     *\n     * @param {IFormatter} formatter Formatter to use.\n     * @returns {Field} Self for chaining.\n     */\n    public setFormatter(formatter: IFormatter): Field;\n    public setFormatter(formatter?: IFormatter): any {\n        if ( formatter === undefined ) {\n            return this._setFormatter;\n        }\n\n        this._setFormatter = formatter;\n        return this;\n    }\n\n    /**\n     * Get the currently applied set value.\n     *\n     * @returns {*} Value - will be undefined by default.\n     */\n    public setValue(): any;\n    /**\n     * Set the set value for the field.\n     *\n     * If given, then this value is used to write to the database regardless\n     *  of what data is sent from the client-side.\n     *\n     * @param {*} val Value to set\n     * @returns {Field} Self for chaining\n     */\n    public setValue(val: any): Field;\n    public setValue(val?: any): any {\n        if ( val === undefined ) {\n            return this._setValue;\n        }\n\n        this._setValue = val;\n        return this;\n    }\n\n    /**\n     * Get the {@link Upload} class for this field.\n     *\n     * @returns {Upload} Configured upload class\n     */\n    public upload(): Upload;\n    /**\n     * Set an {@link Upload} class for this field.\n     *\n     * @param {Upload} upload Upload class instance\n     * @returns {Field} Self for chaining\n     */\n    public upload(upload: Upload): Field;\n    public upload(upload?: Upload): any {\n        if ( upload === undefined ) {\n            return this._upload;\n        }\n\n        this._upload = upload;\n        return this;\n    }\n\n    /**\n     * Get the validators applied to this field.\n     *\n     * @returns {IValidator[]} Array of validators\n     */\n    public validator(): IValidator[];\n    /**\n     * Set the 'validator' of the field.\n     *\n     * The validator can be used to check if any abstract piece of data is valid\n     * or not according to the given rules of the validation function used.\n     *\n     * Multiple validation options can be applied to a field instance by calling\n     * this method multiple times. For example, it would be possible to have a\n     * 'required' validation and a 'maxLength' validation with multiple calls.\n     *\n     * Editor has a number of validation available with the {@link Validate} class\n     * which can be used directly with this method.\n     *\n     * @param {IValidator} validator Validator to add to the field\n     * @returns {Field} Self for chaining\n     */\n    public validator(validator: IValidator): Field;\n    public validator(validator?: IValidator): any {\n        if ( validator === undefined ) {\n            return this._validator;\n        }\n\n        this._validator.push( validator );\n        return this;\n    }\n\n    /**\n     * Get the current XSS formatter.\n     *\n     * @returns {Ixss} XSS formatter. Can be null or undefined.\n     */\n    public xss(): Ixss;\n    /**\n     * Set a formatting method that will be used for XSS checking / removal.\n     * This should be a function that takes a single argument (the value to be\n     * cleaned) and returns the cleaned value.\n     *\n     * Editor will use `xss-filters` by default for this operation, which is built\n     * into the software and no additional configuration is required, but a\n     * custom function can be used if you wish to use a different formatter.\n     *\n     * If you wish to disable this option (which you would only do if you are\n     * absolutely confident that your validation will pick up on any XSS inputs)\n     * simply provide a closure function that returns the value given to the\n     * function. This is _not_ recommended.\n     *\n     * @param {(boolean|Ixss)} flag Enable / disable XSS protection, or set a\n     *   formatter.\n     * @returns {Field} Self for chaining.\n     */\n    public xss(flag: boolean|Ixss): Field;\n    public xss(flag?: boolean|Ixss): any {\n        if ( flag === undefined ) {\n            return this._xss;\n        }\n\n        if ( flag === true ) {\n            this._xss = xss;\n        }\n        else if ( flag === false ) {\n            this._xss = null;\n        }\n        else {\n            this._xss = flag;\n        }\n\n        return this;\n    }\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t * Used by the Editor class and not generally for public use\n\t */\n\n    /**\n     * @hidden\n     */\n    public apply( action: 'get'|'create'|'edit', data?: object ): boolean {\n        if ( action === 'get' ) {\n            return this._get;\n        }\n\n        if ( action === 'create' && (this._set === SetType.None || this._set === SetType.Edit)) {\n            return false;\n        }\n        else if ( action === 'edit' && (this._set === SetType.None || this._set === SetType.Create)) {\n            return false;\n        }\n\n        // Check it was in the submitted data\n        if ( this._setValue === undefined && ! this._propExists( this.name(), data ) ) {\n            return false;\n        }\n\n        // In the data set, so use it\n        return true;\n    }\n\n    /**\n     * @hidden\n     */\n    public async optionsExec( db: knex ): Promise<false|IOption[]> {\n        if ( this._opts instanceof Options ) {\n            return await this._opts.exec( db );\n        }\n        else if ( this._opts ) {\n            return await this._opts( db );\n        }\n        return false;\n    }\n\n    /**\n     * @hidden\n     */\n    public val( direction: 'get'|'set', data: object ): any {\n        let val;\n\n        if ( direction === 'get' ) {\n            if ( this._getValue !== undefined ) {\n                val = typeof this._getValue === 'function' ?\n                    this._getValue() :\n                    this._getValue;\n            }\n            else {\n                // Getting data, so db field name\n                val = data[ this._dbField ] !== undefined ?\n                    data[ this._dbField ] :\n                    null;\n            }\n\n            return this._format( val, data, this._getFormatter );\n        }\n\n        // set - using from the payload, and thus use `name`\n        if ( this._setValue !== undefined ) {\n            val = typeof this._setValue === 'function' ?\n                this._setValue() :\n                this._setValue;\n        }\n        else {\n            val = this._readProp( this._name, data );\n        }\n\n        return this._format( val, data, this._setFormatter );\n    }\n\n    /**\n     * @hidden\n     */\n    public async validate( data: object, editor: Editor, id: string = null ): Promise<true|string> {\n        if ( this._validator.length === 0 ) {\n            return true;\n        }\n\n        let val = this._readProp( this.name(), data );\n        let host = new Validator.Host( {\n            action: editor.inData().action,\n            db: editor.db(),\n            editor,\n            field: this,\n            id\n        } );\n\n        for ( let i = 0, ien = this._validator.length ; i < ien ; i++ ) {\n            let validator = this._validator[i];\n            let res = await validator( val, data, host );\n\n            if ( res !== true ) {\n                return res;\n            }\n        }\n\n        // Validation methods all run, must be value\n        return true;\n    }\n\n    /**\n     * @hidden\n     */\n    public write( out: object, srcData: object ): void {\n        this._writeProp( out, this.name(), this.val('get', srcData) );\n    }\n\n    /**\n     * @hidden\n     */\n    public xssSafety( val: any ) {\n        if ( ! this._xss ) {\n            return val;\n        }\n\n        if ( Array.isArray( val ) ) {\n            let out = [];\n\n            for ( let i = 0, ien = val.length ; i < ien ; i++ ) {\n                out.push( this._xss( val[i] ) );\n            }\n\n            return out;\n        }\n\n        return this._xss( val );\n    }\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n    private _format( val: any, data: object, formatter: IFormatter ): any {\n        return formatter ?\n            formatter( val, data ) :\n            val;\n    }\n}\n"]}