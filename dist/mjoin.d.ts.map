{"version":3,"sources":["mjoin.ts"],"names":[],"mappings":"AAEA,OAAO,MAAM,EAAE,EAAC,UAAU,EAAE,WAAW,EAAC,MAAM,UAAU,CAAC;AACzD,OAAO,KAAK,EAAE,EAAC,OAAO,EAAC,MAAM,SAAS,CAAC;AACvC,OAAO,UAAU,MAAM,cAAc,CAAC;AAQtC;;GAEG;AACH,oBAAY,eAAe,GAC1B,CAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,KAAM,OAAO,CAAC,IAAI,GAAC,MAAM,CAAC,CAAC;AAG9E;;;;;;;;;;;;;;;;GAgBG;AACH,MAAM,CAAC,OAAO,OAAO,KAAM,SAAQ,UAAU;IAC5C,OAAc,OAAO,iBAAW;IAMhC,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,OAAO,CAAS;IACxB,OAAO,CAAC,KAAK,CAAS;IACtB,OAAO,CAAC,IAAI,CAAiB;IAC7B,OAAO,CAAC,IAAI,CAAyB;IACrC,OAAO,CAAC,MAAM,CAAa;IAC3B,OAAO,CAAC,OAAO,CAAe;IAC9B,OAAO,CAAC,MAAM,CAAgB;IAC9B,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,KAAK,CAGX;IACF,OAAO,CAAC,WAAW,CAGX;IAMR;;;;OAIG;gBACU,KAAK,EAAE,MAAM;IAW1B;;;;;OAKG;IACI,KAAK,CAAE,WAAW,EAAE,MAAM;IAC1B,KAAK,CAAE,WAAW,EAAE,KAAK;IAgBhC;;;OAGG;IACI,MAAM,IAAI,KAAK,EAAE;IACxB;;;;OAIG;IACI,MAAM,CAAC,GAAG,MAAM,EAAE,KAAK,EAAE,GAAG,KAAK;IAWxC;;;;OAIG;IACI,GAAG,IAAI,OAAO;IACrB;;;;;;OAMG;IACI,GAAG,CAAC,IAAI,EAAE,OAAO,GAAG,KAAK;IAUhC;;;;;;;;;;;;;;;;;OAiBG;IACI,IAAI,CAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAI,KAAK;IAgBpD;;;;;;;;;OASG;IACI,IAAI,IAAI,MAAM;IACrB;;;;;OAKG;IACI,IAAI,CAAC,IAAI,EAAE,MAAM,GAAG,KAAK;IAUhC;;;;OAIG;IACI,KAAK,IAAI,MAAM;IACtB;;;;;OAKG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,GAAG,KAAK;IAUlC;;;;OAIG;IACI,GAAG,IAAI,OAAO;IACrB;;;;;;;;;;OAUG;IACI,GAAG,CAAC,IAAI,EAAE,OAAO,GAAC,OAAO,GAAG,KAAK;IAmBxC;;;;;;;;;OASG;IACI,KAAK,IAAI,MAAM;IACtB;;;;;OAKG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,GAAG,KAAK;IAUlC;;;;;;OAMG;IACI,SAAS,CAAE,SAAS,EAAE,MAAM,EAAE,EAAE,EAAE,eAAe,GAAI,IAAI;IAShE;;;;OAIG;IACI,KAAK,IAAI,GAAG,EAAE;IACrB;;;;;;OAMG;IACI,KAAK,CAAC,IAAI,EAAE,GAAG,GAAG,KAAK;IAe9B;;OAEG;IACU,IAAI,CAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,GAAI,OAAO,CAAC,IAAI,CAAC;IAuKzE;;OAEG;IACU,MAAM,CAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAI,OAAO,CAAC,IAAI,CAAC;IAsBpF;;OAEG;IACU,MAAM,CAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAI,OAAO,CAAC,IAAI,CAAC;IAiBpF;;OAEG;IACU,MAAM,CAAE,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAI,OAAO,CAAC,IAAI,CAAC;IAqCnE;;OAEG;IACU,QAAQ,CAAE,MAAM,KAAA,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAI,OAAO,CAAC,IAAI,CAAC;IA4B5F,OAAO,CAAC,WAAW;YAQL,OAAO;IAiCrB,OAAO,CAAC,QAAQ;YAkDF,eAAe;CAe7B","file":"mjoin.d.ts","sourcesContent":["import * as knex from 'knex';\n\nimport Editor, {IDtRequest, IDtResponse} from './editor';\nimport Field, {SetType} from './field';\nimport NestedData from './nestedData';\n\ninterface IJoinTable {\n\ttable?: string;\n\tparent: string|string[];\n\tchild: string|string[];\n}\n\n/**\n * Grouped validation\n */\nexport type IMjoinValidator =\n\t( editor: Editor, action: string, data: IDtRequest ) => Promise<true|string>;\n\n\n/**\n * The MJoin class provides a one-to-many join link for Editor. This can\n * be useful in cases were an attribute can take multiple values at the\n * same time - for example cumulative security access levels.\n *\n * Typically the MJoin class should be used with a link table, but this is\n * optional. Please note that if you don't use a link table you should be\n * aware that on edit the linked rows are deleted and then reinserted, thus\n * if any values should be retained they should also be submitted.\n *\n * Please refer to the Editor Node documentation for further information\n * https://editor.datatables.net/manual/node\n *\n * @export\n * @class Mjoin\n * @extends {NestedData}\n */\nexport default class Mjoin extends NestedData {\n\tpublic static SetType = SetType;\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t* Private parameters\n\t*/\n\n\tprivate _table: string;\n\tprivate _editor: Editor;\n\tprivate _name: string;\n\tprivate _get: boolean = true;\n\tprivate _set: SetType = SetType.Both;\n\tprivate _where: any[] = [];\n\tprivate _fields: Field[] = [];\n\tprivate _links: string[] = [];\n\tprivate _order: string;\n\tprivate _join: IJoinTable = {\n\t\tchild: '',\n\t\tparent: ''\n\t};\n\tprivate _validators: Array<{\n\t\tfieldName: string,\n\t\tfn: IMjoinValidator\n\t}> = [];\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\t/**\n\t * Creates an instance of Mjoin.\n\t *\n\t * @param {string} table Table name being joined to\n\t */\n\tconstructor( table: string ) {\n\t\tsuper();\n\n\t\tthis.table( table );\n\t\tthis.name( table );\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Get or field by name, or add a field instance.\n\t *\n\t * @param {(Field|string)} nameOrField Field instance to add, or field name to get\n\t * @returns Mjoin instance if adding a field, Field instance if getting a field.\n\t */\n\tpublic field( nameOrField: string );\n\tpublic field( nameOrField: Field );\n\tpublic field( nameOrField: Field|string ) {\n\t\tif ( typeof nameOrField === 'string' ) {\n\t\t\tfor ( let i = 0, ien = this._fields.length ; i < ien ; i++ ) {\n\t\t\t\tif ( this._fields[i].name() === nameOrField ) {\n\t\t\t\t\treturn this._fields[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error( 'Unknown field: ' + nameOrField );\n\t\t}\n\n\t\tthis._fields.push( nameOrField );\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the fields assigned to this instance.\n\t * @returns {Field[]} Array of fields\n\t */\n\tpublic fields(): Field[];\n\t/**\n\t * Add one or more fields to the instance.\n\t * @param {...Field[]} fields Fields to add\n\t * @returns {Mjoin} Self for chaining\n\t */\n\tpublic fields(...fields: Field[]): Mjoin;\n\tpublic fields(...fields: Field[]): any {\n\t\tif ( fields === undefined || fields.length === 0 ) {\n\t\t\treturn this._fields;\n\t\t}\n\n\t\tthis._fields.push.apply( this._fields, fields );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the `get` flag for all fields in the Mjoin instance.\n\t *\n\t * @returns {boolean} True if gettable, false otherwise.\n\t */\n\tpublic get(): boolean;\n\t/**\n\t * Set the `get` flag for all fields in the Mjoin instance.\n\t * When set to false no read operations will occur on the join tables.\n\t *\n\t * @param {boolean} flag `true` to mark as readable, false otherwise\n\t * @returns {Mjoin} Self for chaining\n\t */\n\tpublic get(flag: boolean): Mjoin;\n\tpublic get(flag?: boolean): any {\n\t\tif ( flag === undefined ) {\n\t\t\treturn this._get;\n\t\t}\n\n\t\tthis._get = flag;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Create a join link between two tables. The order of the fields does not\n\t * matter, but each field must contain the table name as well as the field\n\t * name.\n\t *\n\t * This method can be called a maximum of two times for an Mjoin instance:\n\t *\n\t * * First time, creates a link between the Editor host table and a join\n\t *   table\n\t * * Second time creates the links required for a link table.\n\t *\n\t * Please refer to the Editor Mjoin documentation for further details:\n\t * https://editor.datatables.net/manual/php\n\t *\n\t * @param {string} field1 Table and field name\n\t * @param {string} field2 Table and field name\n\t * @returns {Mjoin} Self for chaining\n\t */\n\tpublic link( field1: string, field2: string ): Mjoin {\n\t\tif ( field1.indexOf('.') === -1 || field2.indexOf('.') === -1 ) {\n\t\t\tthrow new Error( 'Mjoin fields must contain both the table name and the column name' );\n\t\t}\n\n\t\tif ( this._links.length === 4 ) {\n\t\t\tthrow new Error( 'Mjoin link method cannot be called more than twice for a single instance' );\n\t\t}\n\n\t\t// Add to list - it is resolved later on\n\t\tthis._links.push( field1 );\n\t\tthis._links.push( field2 );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the instance's configured name.\n\t *\n\t * The `name` of the Join is the JSON property key that is used when\n\t * 'getting' the data, and the HTTP property key (in a JSON style) when\n\t * 'setting' data. Typically the name of the db table will be used here,\n\t * but this method allows that to be overridden.\n\t *\n\t * @returns {string} Current name.\n\t */\n\tpublic name(): string;\n\t/**\n\t * Set the instance's name\n\t *\n\t * @param {string} name Name to set\n\t * @returns {Mjoin} Self for chaining\n\t */\n\tpublic name(name: string): Mjoin;\n\tpublic name(name?: string): any {\n\t\tif ( name === undefined ) {\n\t\t\treturn this._name;\n\t\t}\n\n\t\tthis._name = name;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the column name to order the data by\n\t *\n\t * @returns {string} SQL column name\n\t */\n\tpublic order(): string;\n\t/**\n\t * Specify the property that the data will be sorted by.\n\t *\n\t * @param {string} order SQL column name to order the data by\n\t * @returns {Mjoin} Self for chaining\n\t */\n\tpublic order(order: string): Mjoin;\n\tpublic order(order?: string): any {\n\t\tif ( order === undefined ) {\n\t\t\treturn this._order;\n\t\t}\n\n\t\tthis._order = order;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the current `set` property for the field.\n\t *\n\t * @returns {SetType} Set configuration\n\t */\n\tpublic set(): SetType;\n\t/**\n\t * Set the field's `set` configuration.\n\t *\n\t * A field can be marked as read only using this option, to be set only\n\t * during an create or edit action or to be set during both actions. This\n\t * provides the ability to have fields that are only set when a new row is\n\t * created (for example a \"created\" time stamp).\n\t *\n\t * @param {(boolean|SetType)} flag Set flag.\n\t * @returns {Field} Self for chaining.\n\t */\n\tpublic set(flag: boolean|SetType): Field;\n\tpublic set(flag?: boolean): any {\n\t\tif ( flag === undefined ) {\n\t\t\treturn this._set;\n\t\t}\n\n\t\tif ( flag === true ) {\n\t\t\tthis._set = SetType.Both;\n\t\t}\n\t\telse if ( flag === false ) {\n\t\t\tthis._set = SetType.None;\n\t\t}\n\t\telse {\n\t\t\tthis._set = flag;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get join table name.\n\t *\n\t * Please note that this will also set the {@link name} used by the Join\n\t * as well. This is for convenience as the JSON output / HTTP input will\n\t * typically use the same name as the database name. If you want to set a\n\t * custom name, the {@link name} method must be called ***after*** this one.\n\t *\n\t * @returns {string} Join table name\n\t */\n\tpublic table(): string;\n\t/**\n\t * Set column join name\n\t *\n\t * @param {string} table Join table name\n\t * @returns {Mjoin} Self for chaining\n\t */\n\tpublic table(table: string): Mjoin;\n\tpublic table(table?: string): any {\n\t\tif ( table === undefined ) {\n\t\t\treturn this._table;\n\t\t}\n\n\t\tthis._table = table;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a validator for the array of data (not on a field basis)\n\t *\n\t * @param fieldName Name of the field that any error should be shown\n\t *   against on the client-side\n\t * @param fn Callback function for validation\n\t */\n\tpublic validator( fieldName: string, fn: IMjoinValidator ): this {\n\t\tthis._validators.push( {\n\t\t\tfieldName,\n\t\t\tfn\n\t\t} );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the array of conditions applied to the method.\n\t *\n\t * @returns {any[]} Knex where conditions.\n\t */\n\tpublic where(): any[];\n\t/**\n\t * Where condition to add to the query used to get data from the database.\n\t * Note that this is applied to the child table.\n\t *\n\t * @param {*} cond Knex query condition\n\t * @returns {Mjoin} Self for chaining.\n\t */\n\tpublic where(cond: any): Mjoin;\n\tpublic where(cond?: any): any {\n\t\tif ( cond === undefined ) {\n\t\t\treturn this._where;\n\t\t}\n\n\t\tthis._where.push( cond );\n\n\t\treturn this;\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t */\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async data( editor: Editor, response: IDtResponse ): Promise<void> {\n\t\tif ( ! this._get ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._prepare( editor );\n\t\tlet fields = this.fields();\n\t\tlet join = this._join;\n\n\t\t// This is something that will likely come in a future version, but it\n\t\t// is a relatively low use feature. Please get in touch if this is\n\t\t// something you require.\n\t\tif ( editor.pkey().length > 1 ) {\n\t\t\tthrow new Error( 'Mjoin is not currently supported with a compound primary key for the main table' );\n\t\t}\n\n\t\tif ( response.data.length ) {\n\t\t\t// If the Editor primary key is join key, then it is read automatically\n\t\t\t// and into Editor's primary key store\n\t\t\tlet dteTable = editor.table()[0];\n\t\t\tlet joinField = join.table ?\n\t\t\t\tjoin.parent[0] :\n\t\t\t\tjoin.parent;\n\t\t\tlet dteTableAlias = dteTable.indexOf(' ') !== -1\n\t\t\t\t? dteTable.split(/ (as )?/i)[2]\n\t\t\t\t: dteTable;\n\t\t\tlet mJoinTable = this._table.indexOf(' ') !== -1\n\t\t\t\t? this._table.split(/ (as )?/i)[0]\n\t\t\t\t: this._table;\n\t\t\tlet mJoinTableAlias = this._table.indexOf(' ') !== -1\n\t\t\t\t? this._table.split(/ (as )?/i)[2]\n\t\t\t\t: this._table;\n\n\t\t\tlet pkeyIsJoin = joinField === editor.pkey()[0] ||\n\t\t\tdteTableAlias + '.' + joinField === editor.pkey()[0];\n\n\t\t\t// Build the basic query\n\t\t\tlet query = editor.db().table( dteTable )\n\t\t\t\t.distinct( dteTableAlias + '.' + joinField + ' as dteditor_pkey' );\n\n\t\t\tlet order = this.order();\n\t\t\tif ( order ) {\n\t\t\t\tlet a = order.split( ' ' );\n\n\t\t\t\tif ( a.length > 1 ) {\n\t\t\t\t\tquery.orderBy( a[0], a[1] );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquery.orderBy( a );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._applyWhere( query );\n\n\t\t\tfor ( let i = 0, ien = fields.length ; i < ien ; i++ ) {\n\t\t\t\tlet field = fields[i];\n\n\t\t\t\tif ( field.apply('get') && field.getValue() === undefined ) {\n\t\t\t\t\tlet dbField = field.dbField();\n\n\t\t\t\t\tif (dbField.indexOf('(') !== -1 ) {\n\t\t\t\t\t\tquery.select( editor.db().raw( dbField + ' as \"' + dbField + '\"' ) );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( dbField.indexOf('.') === -1 ) {\n\t\t\t\t\t\tquery.select( mJoinTableAlias + '.' + dbField + ' as ' + dbField );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tquery.select( dbField );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create the joins\n\t\t\tif ( join.table ) {\n\t\t\t\tquery.innerJoin( join.table, dteTableAlias + '.' + join.parent[0], '=', join.table + '.' + join.parent[1] );\n\t\t\t\tquery.innerJoin( mJoinTable+' as '+mJoinTableAlias, mJoinTableAlias + '.' + join.child[0], '=', join.table + '.' + join.child[1] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery.innerJoin( mJoinTable+' as '+mJoinTableAlias, mJoinTableAlias + '.' + join.child, '=', dteTableAlias + '.' + join.parent );\n\t\t\t}\n\n\t\t\tlet readField = '';\n\t\t\tif ( this._propExists( dteTableAlias + '.' + joinField, response.data[0] ) ) {\n\t\t\t\treadField = dteTableAlias + '.' + joinField;\n\t\t\t}\n\t\t\telse if ( this._propExists( joinField.toString(), response.data[0] ) ) {\n\t\t\t\treadField = joinField.toString();\n\t\t\t}\n\t\t\telse if ( !pkeyIsJoin ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Join was performed on the field \"' + readField + '\" which was not ' +\n\t\t\t\t\t'included in the Editor field list. The join field must be ' +\n\t\t\t\t\t'included as a regular field in the Editor instance.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get list of pkey values and apply as a WHERE IN condition\n\t\t\t// This is primarily useful in server-side processing mode and when filtering\n\t\t\t// the table as it means only a sub-set will be selected\n\t\t\t// This is only applied for \"sensible\" data sets.172 It will just complicate\n\t\t\t// matters for really large data sets:\n\t\t\t// https://stackoverflow.com/questions/21178390/in-clause-limitation-in-sql-server\n\t\t\tif ( response.data.length < 1000 ) {\n\t\t\t\tlet whereIn = [];\n\t\t\t\tlet data = response.data;\n\n\t\t\t\tfor ( let i = 0, ien = data.length; i < ien; i++ ) {\n\t\t\t\t\tlet linkValue = pkeyIsJoin ?\n\t\t\t\t\t\t(data[i] as any).DT_RowId.replace( editor.idPrefix(), '' ) :\n\t\t\t\t\t\tthis._readProp( readField, data[i] );\n\n\t\t\t\t\twhereIn.push( linkValue );\n\t\t\t\t}\n\n\t\t\t\tquery.whereIn( dteTableAlias + '.' + joinField, whereIn );\n\t\t\t}\n\n\t\t\tlet res = await query;\n\n\t\t\t// Map the data to the primary key for fast loop up\n\t\t\tlet joinMap = {};\n\n\t\t\tfor ( let i = 0, ien = res.length ; i < ien ; i++ ) {\n\t\t\t\tlet inner = {};\n\n\t\t\t\tfor ( let j = 0, jen = fields.length ; j < jen ; j++ ) {\n\t\t\t\t\tfields[j].write( inner, res[i] );\n\t\t\t\t}\n\n\t\t\t\tlet lookup = res[i].dteditor_pkey;\n\n\t\t\t\tif ( ! joinMap[ lookup ] ) {\n\t\t\t\t\tjoinMap[ lookup ] = [];\n\t\t\t\t}\n\n\t\t\t\tjoinMap[ lookup ].push( inner );\n\t\t\t}\n\n\t\t\t// Loop over the data in the original response and do a join based on\n\t\t\t// the mapped data\n\t\t\tfor ( let i = 0, ien = response.data.length ; i < ien ; i++ ) {\n\t\t\t\tlet data = response.data[i];\n\t\t\t\tlet linkField = pkeyIsJoin ?\n\t\t\t\t\t(data as any).DT_RowId.replace( editor.idPrefix(), '' ) :\n\t\t\t\t\tthis._readProp( readField, data );\n\n\t\t\t\tif ( joinMap[ linkField ] ) {\n\t\t\t\t\tdata[ this._name ] = joinMap[ linkField ];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdata[ this._name ] = [];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Field options\n\t\tfor ( let i = 0, ien = fields.length ; i < ien ; i++ ) {\n\t\t\tlet opts = await fields[i].optionsExec( editor.db() );\n\n\t\t\tif ( opts ) {\n\t\t\t\tlet name = this.name() + '[].' + fields[i].name();\n\n\t\t\t\tresponse.options[ name ] = opts;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async create( editor: Editor, parentId: string, data: object ): Promise<void> {\n\t\t// Not settable\n\t\tif (this._set !== SetType.Create && this._set !== SetType.Both) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The many count for the join was not submitted then we do nothing\n\t\tif (\n\t\t\t! data[ this._name ] ||\n\t\t\t! data[ this._name + '-many-count']\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._prepare( editor );\n\t\tlet db = editor.db();\n\n\t\tfor ( let i = 0, ien = data[ this._name ].length ; i < ien ; i++ ) {\n\t\t\tawait this._insert( db, parentId, data[ this._name ][i] );\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async update( editor: Editor, parentId: string, data: object ): Promise<void> {\n\t\t// Not settable\n\t\tif (this._set !== SetType.Edit && this._set !== SetType.Both) {\n\t\t\treturn;\n\t\t}\n\n\t\t// The many count for the join was not submitted then we do nothing\n\t\tif (data[ this._name + '-many-count'] === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// WARNING - this will remove rows and then readd them. Any\n\t\t// data not in the field list WILL BE LOST\n\t\tawait this.remove( editor, [parentId] );\n\t\tawait this.create( editor, parentId, data );\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async remove( editor: Editor, ids: string[] ): Promise<void> {\n\t\tif ( ! this._set ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._prepare( editor );\n\t\tlet db = editor.db();\n\t\tlet join = this._join;\n\n\t\tif ( join.table ) {\n\t\t\tlet query = db\n\t\t\t\t.del()\n\t\t\t\t.from( join.table );\n\n\t\t\tfor ( let i = 0, ien = ids.length ; i < ien ; i++ ) {\n\t\t\t\tquery.orWhere( { [join.parent[1]]: ids[i] } );\n\t\t\t}\n\n\t\t\tawait query;\n\t\t}\n\t\telse {\n\t\t\tlet query = db\n\t\t\t\t.del()\n\t\t\t\t.from( this._table );\n\n\t\t\tquery.where( function() {\n\t\t\t\tfor ( let i = 0, ien = ids.length ; i < ien ; i++ ) {\n\t\t\t\t\tquery.orWhere( { [join.child.toString()]: ids[i] } );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tthis._applyWhere( query );\n\n\t\t\tawait query;\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic async validate( errors, editor: Editor, data: object, action: string ): Promise<void> {\n\t\tif ( ! this._set ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._prepare( editor );\n\t\tlet joinData = data[ this._name ] || [];\n\n\t\tfor ( let j = 0, jen=this._validators.length ; j < jen ; j++ ) {\n\t\t\tlet validator = this._validators[j];\n\t\t\tlet res = await validator.fn( editor, action, joinData );\n\n\t\t\tif ( typeof res === 'string' ) {\n\t\t\t\terrors.push( {\n\t\t\t\t\tname: validator.fieldName,\n\t\t\t\t\tstatus: res\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tfor ( let i = 0, ien = joinData.length ; i < ien ; i++ ) {\n\t\t\tawait this._validateFields( errors, editor, joinData[i], this._name + '[].', action );\n\t\t}\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\tprivate _applyWhere( query: knex.QueryBuilder<any, any> ): void {\n\t\tlet where = this._where;\n\n\t\tfor ( let i = 0, ien = where.length ; i < ien ; i++ ) {\n\t\t\tquery.where( where[i] );\n\t\t}\n\t}\n\n\tprivate async _insert( db: knex, parentId: string, data: object ): Promise<void> {\n\t\tlet join = this._join;\n\t\tlet fields = this.fields();\n\n\t\tif ( join.table ) {\n\t\t\t// Insert keys into the join table\n\t\t\tawait db\n\t\t\t\t.insert( {\n\t\t\t\t\t[join.parent[1]]: parentId,\n\t\t\t\t\t[join.child[1]]: data[ join.child[0] ]\n\t\t\t\t} )\n\t\t\t\t.from( join.table );\n\t\t}\n\t\telse {\n\t\t\t// Insert values into the target table\n\t\t\tlet set = {\n\t\t\t\t[join.child.toString()]: parentId\n\t\t\t};\n\n\t\t\tfor ( let i = 0, ien = fields.length ; i < ien ; i++ ) {\n\t\t\t\tlet field = fields[i];\n\n\t\t\t\tif ( field.apply('create', data) ) {\n\t\t\t\t\tset[ field.dbField() ] = field.val( 'set', data );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait db\n\t\t\t\t.insert( set )\n\t\t\t\t.from( this._table );\n\t\t}\n\t}\n\n\tprivate _prepare( editor: Editor ): void {\n\t\tthis._editor = editor;\n\n\t\tlet links = this._links;\n\t\tlet editorTable = editor.table()[0];\n\t\tlet joinTable = this.table();\n\t\tlet dteTableAlias = editorTable.indexOf(' ') !== -1\n\t\t\t? editorTable.split(/ (as )?/i)[2]\n\t\t\t: editorTable;\n\n\t\tif ( links.length === 2 ) {\n\t\t\t// No link table\n\t\t\tlet f1 = links[0].split('.');\n\t\t\tlet f2 = links[1].split('.');\n\n\t\t\tif ( f1[0] === dteTableAlias ) {\n\t\t\t\tthis._join.parent = f1[1];\n\t\t\t\tthis._join.child = f2[1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._join.parent = f2[1];\n\t\t\t\tthis._join.child = f1[1];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Link table\n\t\t\tlet f1 = links[0].split('.');\n\t\t\tlet f2 = links[1].split('.');\n\t\t\tlet f3 = links[2].split('.');\n\t\t\tlet f4 = links[3].split('.');\n\n\t\t\t// Discover the name of the link table\n\t\t\tif ( f1[0] !== dteTableAlias && f1[0] !== joinTable ) {\n\t\t\t\tthis._join.table = f1[0];\n\t\t\t}\n\t\t\telse if ( f2[0] !== dteTableAlias && f2[0] !== joinTable ) {\n\t\t\t\tthis._join.table = f2[0];\n\t\t\t}\n\t\t\telse if ( f3[0] !== dteTableAlias && f3[0] !== joinTable ) {\n\t\t\t\tthis._join.table = f3[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._join.table = f4[0];\n\t\t\t}\n\n\t\t\tthis._join.parent = [ f1[1], f2[1] ];\n\t\t\tthis._join.child = [ f3[1], f4[1] ];\n\t\t}\n\t}\n\n\tprivate async _validateFields( errors, editor: Editor, data: object, prefix: string, action: string ): Promise<void> {\n\t\tlet fields = this.fields();\n\n\t\tfor ( let i = 0, ien = fields.length ; i < ien ; i++ ) {\n\t\t\tlet field = fields[i];\n\t\t\tlet validation = await field.validate( data, editor, null, action );\n\n\t\t\tif ( validation !== true ) {\n\t\t\t\terrors.push( {\n\t\t\t\t\tname: prefix + field.name(),\n\t\t\t\t\tstatus: validation\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t}\n}\n"]}