{"version":3,"sources":["nestedData.ts"],"names":[],"mappings":"AACA;;;;;;GAMG;AACH,MAAM,CAAC,OAAO,OAAO,UAAU;IAC9B;;;;;;;OAOG;IACH,SAAS,CAAC,WAAW,CAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAI,OAAO;IA0B5D;;;;;;;OAOG;IACH,SAAS,CAAC,SAAS,CAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,GAAI,GAAG;IAwBtD;;;;;;;;OAQG;IACH,SAAS,CAAC,UAAU,CAAE,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,GAAI,IAAI;CAmCnE","file":"nestedData.d.ts","sourcesContent":["\n/**\n * Class that provides methods to read and write from nested JSON objects,\n * using dot notation strings for the nesting. This class should be extended\n * by any wishing to use these abilities.\n * @export\n * @class NestedData\n */\nexport default class NestedData {\n\t/**\n\t * @hidden\n\t * Check if a nested property exists in a data set.\n\t * @protected\n\t * @param {string} name Property name\n\t * @param {object} data Data set to check\n\t * @returns {boolean} `true` if present, `false` otherwise\n\t */\n\tprotected _propExists( name: string, data: object ): boolean {\n\t\tif (data === undefined) {\n\t\t  return false;\n\t\t}\n\t\tif ( name.indexOf('.') === -1 ) {\n\t\t\treturn data[ name ] === undefined ?\n\t\t\t\tfalse :\n\t\t\t\ttrue;\n\t\t}\n\n\t\tlet names = name.split('.');\n\t\tlet inner = data;\n\n\t\tfor ( let i = 0, ien = names.length - 1; i < ien; i++ ) {\n\t\t\tif ( inner[ names[i] ] === undefined ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tinner = inner[ names[i] ];\n\t\t}\n\n\t\treturn inner[ names[names.length - 1] ] === undefined ?\n\t\t\tfalse :\n\t\t\ttrue;\n\t}\n\n\t/**\n\t * @hidden\n\t * Get a nested property value.\n\t * @protected\n\t * @param {string} name Property name\n\t * @param {object} data Data set to check\n\t * @returns {*} Value\n\t */\n\tprotected _readProp( name: string, data: object ): any {\n\t\tif ( name.indexOf('.') === -1 ) {\n\t\t\treturn data[ name ] !== undefined ?\n\t\t\t\tdata[ name ] :\n\t\t\t\tnull;\n\t\t}\n\n\t\tlet names = name.split('.');\n\t\tlet inner = data;\n\n\t\tfor ( let i = 0, ien = names.length - 1; i < ien; i++ ) {\n\t\t\tif ( inner[ names[i] ] === undefined ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tinner = inner[ names[i] ];\n\t\t}\n\n\t\tlet idx = names[names.length - 1];\n\t\treturn inner[ idx ] !== undefined ?\n\t\t\tinner[ idx ] :\n\t\t\tnull;\n\t}\n\n\t/**\n\t * @hidden\n\t * Write a value to a nested data object.\n\t * @protected\n\t * @param {object} out Data object to write the value into\n\t * @param {string} name Nested property name to write to\n\t * @param {*} value Value to write\n\t * @returns {void} No return.\n\t */\n\tprotected _writeProp( out: object, name: string, value: any ): void {\n\t\tif ( name.indexOf('.') === -1 ) {\n\t\t\tout[ name ] = value;\n\t\t\treturn;\n\t\t}\n\n\t\tlet names = name.split('.');\n\t\tlet inner = out;\n\n\t\tfor ( let i = 0, ien = names.length - 1; i < ien; i++ ) {\n\t\t\tlet loopName = names[i];\n\n\t\t\tif ( inner[ loopName ] === undefined ) {\n\t\t\t\tinner[ loopName ] = {};\n\t\t\t}\n\t\t\telse if ( typeof inner[ loopName ] !== 'object' ) {\n\t\t\t\tthrow new Error('A property with the name `' + name + '` already exists. ' +\n\t\t\t\t\t'This can occur if you have properties which share a prefix - ' +\n\t\t\t\t\t'for example `name` and `name.first`.'\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tinner = inner[ loopName ];\n\t\t}\n\n\t\tlet idx = names[ names.length - 1 ];\n\n\t\tif ( inner[ idx ] !== undefined ) {\n\t\t\tthrow new Error( 'Duplicate field detected - a field with the name ' +\n\t\t\t\t'`' + name + '` already exists'\n\t\t\t);\n\t\t}\n\n\t\tinner[ idx ] = value;\n\t}\n}\n"]}