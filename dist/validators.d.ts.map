{"version":3,"sources":["validators.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AAM5B,OAAO,EAAE,eAAe,EAAE,MAAM,SAAS,CAAC;AAE1C,OAAO,EAAE,KAAK,EAAE,MAAM,UAAU,CAAC;AACjC,OAAO,cAAc,MAAM,kBAAkB,CAAC;AAC9C,OAAO,iBAAiB,MAAM,qBAAqB,CAAC;AAIpD,MAAM,MAAM,UAAU,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,cAAc,KAAK,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,CAAC;AAClG,MAAM,MAAM,cAAc,GAAG,CAAC,IAAI,EAAE,KAAK,KAAK,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,CAAC;AAErE;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAM,CAAC,OAAO,OAAO,SAAS;IAC7B,OAAc,OAAO,2BAAqB;IAC1C,OAAc,IAAI,wBAAkB;IAEpC;;;;;;OAMG;WACW,IAAI,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAUpE;;;;;;;;;OASG;WACW,KAAK,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAcrE;;;;;;OAMG;WACW,QAAQ,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAgBxE;;;;;;OAMG;WACW,QAAQ,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAexE;;;;;;OAMG;WACW,OAAO,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IA8CvE;;;;;;;OAOG;WACW,OAAO,CAAC,OAAO,GAAE,MAAY,EAAE,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IA8B9F;;;;;;;;OAQG;WACW,MAAM,CACnB,GAAG,EAAE,MAAM,EACX,OAAO,GAAE,MAAY,EACrB,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAClC,UAAU;IA2Bb;;;;;;;;OAQG;WACW,MAAM,CACnB,GAAG,EAAE,MAAM,EACX,OAAO,GAAE,MAAY,EACrB,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAClC,UAAU;IAqBb;;;;;;;;;OASG;WACW,SAAS,CACtB,GAAG,EAAE,MAAM,EACX,GAAG,EAAE,MAAM,EACX,OAAO,GAAE,MAAY,EACrB,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAClC,UAAU;IAyBb;;;;;;OAMG;WACW,KAAK,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAoBrE;;;;;;;OAOG;WACW,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAiBnF;;;;;;;OAOG;WACW,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAiBnF;;;;;;;;OAQG;WACW,SAAS,CACtB,GAAG,EAAE,MAAM,EACX,GAAG,EAAE,MAAM,EACX,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAClC,UAAU;IAiBb;;;;;;OAMG;WACW,EAAE,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAiClE;;;;;;OAMG;WACW,GAAG,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAiBnE;;;;;;OAMG;WACW,GAAG,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAmBnE;;;;;;;OAOG;WACW,MAAM,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAiBrF;;;;;;OAMG;WACW,MAAM,CAAC,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAAG,UAAU;IAqBtE;;;;;;;;OAQG;WACW,UAAU,CACvB,MAAM,EAAE,MAAM,EACd,MAAM,GAAE,MAAM,GAAG,IAAW,EAC5B,GAAG,GAAE,iBAAiB,GAAG,IAAW,GAClC,UAAU;IAyBb;;;;;;;;;;;;OAYG;WACW,QAAQ,CACrB,GAAG,GAAE,iBAAiB,GAAG,IAAW,EACpC,MAAM,GAAE,MAAM,GAAG,IAAW,EAC5B,KAAK,GAAE,MAAM,GAAG,IAAW,EAC3B,EAAE,GAAE,IAAI,GAAG,IAAW,GACpB,UAAU;IA2Cb;;;;;;;;;;;;;;;;OAgBG;WACW,QAAQ,CACrB,GAAG,GAAE,iBAAiB,GAAG,IAAW,EACpC,MAAM,GAAE,MAAM,GAAG,IAAW,EAC5B,KAAK,GAAE,MAAM,GAAG,IAAW,EAC3B,EAAE,GAAE,IAAI,GAAG,IAAW,EACtB,MAAM,GAAE,GAAG,EAAO,GAChB,UAAU;IAoDb;;;;;;;OAOG;WACW,cAAc,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,GAAG,EAAE,MAAM,GAAG,cAAc;IAY1E;;;;;;OAMG;WACW,QAAQ,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,GAAG,cAAc;IAUjE;;;;;;;;OAQG;WACW,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,GAAG,eAAe;IASvE;;;;;;;;OAQG;WACW,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,GAAG,eAAe;IAavE,OAAO,CAAC,MAAM,CAAC,OAAO;IAqCtB;;;;;;;;;OASG;IACH,OAAO,CAAC,MAAM,CAAC,YAAY;CAe3B","file":"validators.d.ts","sourcesContent":["import * as knex from 'knex';\nimport { Knex } from 'knex';\nimport * as moment from 'moment';\nimport * as validUrl from 'valid-url';\n\nimport Editor from './editor';\nimport Field from './field';\nimport { IMjoinValidator } from './mjoin';\nimport { default as JoinOptions } from './options';\nimport { IFile } from './upload';\nimport ValidationHost from './validationHost';\nimport ValidationOptions from './validationOptions';\n\n// Note that validators return a Promise to allow async validators, such as\n// checking a value is unique against the database\nexport type IValidator = (val: any, data: object, host: ValidationHost) => Promise<true | string>;\nexport type IFileValidator = (file: IFile) => Promise<true | string>;\n\n/**\n * Validation methods for DataTables Editor fields. All of the methods\n * defined in this class return a function that can be used by\n * {@link Field} instance's {@link Field.Validator} method.\n *\n * Each method may define its own parameters that configure how the\n * formatter operates. For example the `minLen` validator takes information\n * on the minimum length of value to accept.\n *\n * Additionally each method can optionally take a `ValidationOptions`\n * instance that controls common validation options and error messages.\n *\n * The validation functions return `true` for valid data and a string for\n * invalid data, with the string being the error message.\n *\n * @export\n * @class Validator\n */\nexport default class Validator {\n\tpublic static Options = ValidationOptions;\n\tpublic static Host = ValidationHost;\n\n\t/**\n\t * No validation - all inputs are valid\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static none(cfg: ValidationOptions | null = null): IValidator {\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/**\n\t * Basic validation - this is used to perform the validation provided by the\n\t * validation options only. If the validation options pass (e.g. `required`,\n\t * `empty` and `optional`) then the validation will pass regardless of the\n\t * actual value.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static basic(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\n\t\t\treturn common === false ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Required field - there must be a value and it must be a non-empty value\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static required(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\t\topts.empty(false);\n\t\topts.optional(false);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\n\t\t\treturn common === false ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Optional field, but if given there must be a non-empty value\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static notEmpty(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\t\topts.empty(false);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\n\t\t\treturn common === false ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Validate an input as a boolean value.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static boolean(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tif (typeof val === 'string') {\n\t\t\t\tval = val.toLocaleLowerCase();\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tval === true ||\n\t\t\t\tval === 1 ||\n\t\t\t\tval === '1' ||\n\t\t\t\tval === 'true' ||\n\t\t\t\tval === 't' ||\n\t\t\t\tval === 'on' ||\n\t\t\t\tval === 'yes' ||\n\t\t\t\tval === 'âœ“' ||\n\t\t\t\tval === 'x' ||\n\t\t\t\tval === false ||\n\t\t\t\tval === 0 ||\n\t\t\t\tval === '0' ||\n\t\t\t\tval === 'false' ||\n\t\t\t\tval === 'f' ||\n\t\t\t\tval === 'off' ||\n\t\t\t\tval === 'no'\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn opts.message();\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Number validation methods\n\t */\n\n\t/**\n\t * Check that any input is numeric.\n\t *\n\t * @static\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static numeric(decimal: string = '.', cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tif (typeof val === 'number') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (decimal !== '.') {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\tval = val.trim();\n\t\t\tif (val === '') {\n\t\t\t\treturn opts.message();\n\t\t\t}\n\n\t\t\treturn isNaN(Number(val)) ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Check for a numeric input and that it is greater than a given value.\n\t *\n\t * @static\n\t * @param {number} min Minimum value\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minNum(\n\t\tmin: number,\n\t\tdecimal: string = '.',\n\t\tcfg: ValidationOptions | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet numeric = await Validator.numeric(decimal, opts)(val, data, host);\n\t\t\tif (numeric !== null) {\n\t\t\t\treturn numeric;\n\t\t\t}\n\n\t\t\t// val.toString() for '' is 0, which would mean it would always fail, even if empty values\n\t\t\t// are allowed.\n\t\t\tif (val === '' && opts.empty()) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (decimal !== '.') {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\treturn val < min ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Check for a numeric input and that it is less than a given value.\n\t *\n\t * @static\n\t * @param {number} max Maximum value\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static maxNum(\n\t\tmax: number,\n\t\tdecimal: string = '.',\n\t\tcfg: ValidationOptions | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet numeric = await Validator.numeric(decimal, opts)(val, data, host);\n\t\t\tif (numeric !== null) {\n\t\t\t\treturn numeric;\n\t\t\t}\n\n\t\t\tif (decimal !== '.') {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\treturn val > max ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Check for a numeric input and that it is in between two given values.\n\t *\n\t * @static\n\t * @param {number} min Minimum value\n\t * @param {number} max Maximum value\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minMaxNum(\n\t\tmin: number,\n\t\tmax: number,\n\t\tdecimal: string = '.',\n\t\tcfg: ValidationOptions | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet numeric = await Validator.numeric(decimal, opts)(val, data, host);\n\t\t\tif (numeric !== null) {\n\t\t\t\treturn numeric;\n\t\t\t}\n\n\t\t\tif (decimal !== '.') {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\treturn val < min || val > max ? opts.message() : true;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * String validation methods\n\t */\n\n\t/**\n\t * Validate an input as an e-mail address.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static email(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tlet re =\n\t\t\t\t/^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n\n\t\t\treturn re.test(val) ? true : opts.message();\n\t\t};\n\t}\n\n\t/**\n\t * Validate a string has a minimum length.\n\t *\n\t * @static\n\t * @param {number} min Minimum length\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minLen(min: number, cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\treturn val.length < min ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Validate a string is less or equal to a maximum length.\n\t *\n\t * @static\n\t * @param {number} max Maximum length\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static maxLen(max: number, cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\treturn val.length > max ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Require a string with a certain minimum or maximum number of characters.\n\t *\n\t * @static\n\t * @param {number} min Minimum length\n\t * @param {number} max Maximum length\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minMaxLen(\n\t\tmin: number,\n\t\tmax: number,\n\t\tcfg: ValidationOptions | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\treturn val.length < min || val.length > max ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Validate as an IP address.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static ip(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tlet a = val.split('.');\n\t\t\tif (a.length !== 4) {\n\t\t\t\treturn opts.message();\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tlet parsed = parseInt(a[i], 10);\n\t\t\t\tif (parsed !== a[i] * 1) {\n\t\t\t\t\treturn opts.message();\n\t\t\t\t}\n\n\t\t\t\tif (parsed < 0 || parsed > 255) {\n\t\t\t\t\treturn opts.message();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/**\n\t * Validate as a URL.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static url(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\treturn !validUrl.isWebUri(val) ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Check if string could contain an XSS attack string\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static xss(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tlet field = host.field;\n\n\t\t\treturn field.xssSafety(val) !== val ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Confirm that the value submitted is in a list of allowable values\n\t *\n\t * @static\n\t * @param {any[]} values List of values that are valid\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static values(values: any[], cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\treturn values.includes(val) ? true : opts.message();\n\t\t};\n\t}\n\n\t/**\n\t * Ensure that the submitted string does not contain HTML tags\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static noTags(cfg: ValidationOptions | null = null): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\treturn val.toString().test(/<.*>/) ? opts.message() : true;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Date validation methods\n\t */\n\n\t/**\n\t * Check that a valid date input is given. Uses MomentJS\n\t *\n\t * @static\n\t * @param {string} format MomentJS date format\n\t * @param {string} [locale=null] MomentJS locale\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static dateFormat(\n\t\tformat: string,\n\t\tlocale: string | null = null,\n\t\tcfg: ValidationOptions | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tlet res = locale\n\t\t\t\t? moment(val, format, locale, true).isValid()\n\t\t\t\t: moment(val, format, true).isValid();\n\n\t\t\treturn !res ? opts.message() : true;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Database validation\n\t */\n\n\t/**\n\t * Check that the given value is unique in the database\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @param {string} [column=null] Column name to use to check as a unique\n\t *   value. If not given the host field's database column name is used\n\t * @param {string} [table=null] Table to check that this value is uniquely\n\t *   valid on. If not given the host Editor's table name is used\n\t * @param {Knex} [db=null] Database connection. If not given the host\n\t *   Editor's database connection is used\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static dbUnique(\n\t\tcfg: ValidationOptions | null = null,\n\t\tcolumn: string | null = null,\n\t\ttable: string | null = null,\n\t\tdb: Knex | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tif (db === null) {\n\t\t\t\tdb = host.db;\n\t\t\t}\n\n\t\t\tif (table === null) {\n\t\t\t\ttable = host.editor.table()[0];\n\t\t\t}\n\n\t\t\tif (column === null) {\n\t\t\t\tcolumn = host.field.dbField();\n\t\t\t}\n\n\t\t\tlet q = db\n\t\t\t\t.table(table)\n\t\t\t\t.select(column)\n\t\t\t\t.where({ [column]: val });\n\n\t\t\t// If doing an edit then we need to also discount the current row,\n\t\t\t// since it is of course already validly unique\n\t\t\tif (host.action === 'edit') {\n\t\t\t\tlet cond = host.editor.pkeyToObject(host.id, true);\n\t\t\t\tq.whereNot(cond);\n\t\t\t}\n\n\t\t\tlet res = await q;\n\n\t\t\treturn res.length ? opts.message() : true;\n\t\t};\n\t}\n\n\t/**\n\t * Check that the given value is a value that is available in a database -\n\t * i.e. a join primary key. This will attempt to automatically use the table\n\t * name and value column from the field's `Options` method (under the\n\t * assumption that it will typically be used with a joined field), but the\n\t * table and field can also be specified via the options.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @param {string} [column=null] Column name to use to check as a unique\n\t *   value. If not given the host field's database column name is used\n\t * @param {string} [table=null] Table to check that this value is uniquely\n\t *   valid on. If not given the host Editor's table name is used\n\t * @param {Knex} [db=null] Database connection. If not given the host\n\t *   Editor's database connection is used\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static dbValues(\n\t\tcfg: ValidationOptions | null = null,\n\t\tcolumn: string | null = null,\n\t\ttable: string | null = null,\n\t\tdb: Knex | null = null,\n\t\tvalues: any[] = []\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select(cfg);\n\n\t\treturn async function (\n\t\t\tval: any,\n\t\t\tdata: object,\n\t\t\thost: ValidationHost\n\t\t): Promise<true | string> {\n\t\t\tlet common = Validator._common(val, opts, data, host);\n\t\t\tlet options = host.field.options();\n\n\t\t\tif (common !== null) {\n\t\t\t\treturn common === false ? opts.message() : true;\n\t\t\t}\n\n\t\t\tif (values.indexOf(val) !== -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (db === null) {\n\t\t\t\tdb = host.db;\n\t\t\t}\n\n\t\t\tif (table === null && options instanceof JoinOptions) {\n\t\t\t\ttable = options.table();\n\t\t\t}\n\n\t\t\tif (column === null && options instanceof JoinOptions) {\n\t\t\t\tcolumn = options.value();\n\t\t\t}\n\n\t\t\tif (table === null || column === null) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Table or column for database value check is not ' +\n\t\t\t\t\t\t'defined for field ' +\n\t\t\t\t\t\thost.field.name()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet res = await db\n\t\t\t\t.from(table)\n\t\t\t\t.select(column)\n\t\t\t\t.where({ [column]: val });\n\n\t\t\treturn !res || !res.length ? opts.message() : true;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * File upload validators\n\t */\n\n\t/**\n\t * Check that the uploaded file has a given extension\n\t *\n\t * @static\n\t * @param {string[]} extns Allowed extensions\n\t * @param {string} msg Error message to return if not valid\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static fileExtensions(extns: string[], msg: string): IFileValidator {\n\t\treturn async function (file: IFile) {\n\t\t\tfor (let i = 0, ien = extns.length; i < ien; i++) {\n\t\t\t\tif (file.extn.toLowerCase() === extns[i].toLowerCase()) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn msg;\n\t\t};\n\t}\n\n\t/**\n\t * Check that the uploaded file is equal or less than a given size.\n\t *\n\t * @static\n\t * @param {string[]} size Max file size in bytes\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static fileSize(size: number, msg: string): IFileValidator {\n\t\treturn async function (file: IFile) {\n\t\t\treturn file.size > size ? msg : true;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Mjoin validators\n\t */\n\n\t/**\n\t * Require a minimum value of the number of options / values submitted in\n\t * an array\n\t *\n\t * @static\n\t * @param size Min array size required to be valid\n\t * @param msg Error message\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static mjoinMinCount(size: number, msg: string): IMjoinValidator {\n\t\treturn async function (editor: Editor, action: string, data: any[]) {\n\t\t\tif (action === 'create' || action === 'edit') {\n\t\t\t\treturn data.length < size ? msg : true;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/**\n\t * Require a maximum value of the number of options / values submitted in\n\t * an array\n\t *\n\t * @static\n\t * @param size Max array size required to be valid\n\t * @param msg Error message\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static mjoinMaxCount(size: number, msg: string): IMjoinValidator {\n\t\treturn async function (editor: Editor, action: string, data: any[]) {\n\t\t\tif (action === 'create' || action === 'edit') {\n\t\t\t\treturn data.length > size ? msg : true;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t */\n\n\tprivate static _common(\n\t\tval: any,\n\t\topts: ValidationOptions,\n\t\tdata: any,\n\t\thost: ValidationHost\n\t): boolean | null {\n\t\t// Check if the validator should be applied. If not, then it will pass (i.e. as if\n\t\t// there was no validator). If the validator should apply, fall through to the actual\n\t\t// validator function.\n\t\tif (Validator._conditional(val, opts, data, host) === false) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Error state tests\n\t\tif (!opts.optional() && val === null) {\n\t\t\t// Value must be given\n\t\t\treturn false;\n\t\t}\n\n\t\tif (val !== null && opts.empty() === false && val === '') {\n\t\t\t// Value must not be empty\n\t\t\treturn false;\n\t\t}\n\n\t\t// Validate passed states\n\t\tif (opts.optional() && val === null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (opts.empty() === true && val === '') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Have the specific validation function perform its tests\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check if this validator should run or not\n\t *\n\t * @param val Field's value\n\t * @param opts Validator options\n\t * @param data Row's submitted data\n\t * @param host Validation host\n\t * @returns `true` if there is no condition, or if there is one and the condition\n\t *   matches, or `false` if there is a condition and it doesn't match.\n\t */\n\tprivate static _conditional(\n\t\tval: any,\n\t\topts: ValidationOptions,\n\t\tdata: any,\n\t\thost: ValidationHost\n\t): boolean {\n\t\tconsole.log('conditional check', opts);\n\t\tif (!opts) {\n\t\t\t// No options, so there can be no condition. Validator applies.\n\t\t\treturn true;\n\t\t}\n\n\t\t// Otherwise, let the options dependency runner return the value\n\t\treturn opts.runDepends(val, data, host);\n\t}\n}\n"]}