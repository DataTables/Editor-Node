{"version":3,"sources":["validators.ts"],"names":[],"mappings":"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","file":"validators.d.ts","sourcesContent":["import * as knex from 'knex';\nimport * as moment from 'moment';\nimport * as validUrl from 'valid-url';\n\nimport Editor from './editor';\nimport Field from './field';\nimport {IMjoinValidator} from './mjoin';\nimport {default as JoinOptions} from './options';\nimport {IFile} from './upload';\nimport ValidationHost from './validationHost';\nimport ValidationOptions from './validationOptions';\n\n// Note that validators return a Promise to allow async validators, such as\n// checking a value is unique against the database\nexport type IValidator = (val: any, data: object, host: ValidationHost) => Promise<true|string>;\nexport type IFileValidator = (file: IFile) => Promise<true|string>;\n\n/**\n * Validation methods for DataTables Editor fields. All of the methods\n * defined in this class return a function that can be used by\n * {@link Field} instance's {@link Field.Validator} method.\n *\n * Each method may define its own parameters that configure how the\n * formatter operates. For example the `minLen` validator takes information\n * on the minimum length of value to accept.\n *\n * Additionally each method can optionally take a `ValidationOptions`\n * instance that controls common validation options and error messages.\n *\n * The validation functions return `true` for valid data and a string for\n * invalid data, with the string being the error message.\n *\n * @export\n * @class Validator\n */\nexport default class Validator {\n\tpublic static Options = ValidationOptions;\n\tpublic static Host = ValidationHost;\n\n\t/**\n\t * No validation - all inputs are valid\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static none( cfg: ValidationOptions | null = null ): IValidator {\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/**\n\t * Basic validation - this is used to perform the validation provided by the\n\t * validation options only. If the validation options pass (e.g. `required`,\n\t * `empty` and `optional`) then the validation will pass regardless of the\n\t * actual value.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static basic( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\n\t\t\treturn common === false ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Required field - there must be a value and it must be a non-empty value\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static required( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\t\topts.empty = false;\n\t\topts.optional = false;\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\n\t\t\treturn common === false ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Optional field, but if given there must be a non-empty value\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static notEmpty( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\t\topts.empty = false;\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\n\t\t\treturn common === false ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Validate an input as a boolean value.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static boolean( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tval === true || val === 1 || val === '1' || val === 'true' || val === 't' ||\n\t\t\t\tval === 'on' || val === 'yes' || val === false || val === 0 || val === '0' ||\n\t\t\t\tval === 'false' || val === 'f' || val === 'off' || val === 'no'\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn opts.message;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Number validation methods\n\t */\n\n\t/**\n\t * Check that any input is numeric.\n\t *\n\t * @static\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static numeric( decimal: string = '.', cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tif (typeof val === 'number') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( decimal !== '.' ) {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\tval = val.trim();\n\t\t\tif (val === '') {\n\t\t\t\treturn opts.message;\n\t\t\t}\n\n\t\t\treturn isNaN(Number(val)) ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Check for a numeric input and that it is greater than a given value.\n\t *\n\t * @static\n\t * @param {number} min Minimum value\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minNum( min: number, decimal: string = '.', cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet numeric = await Validator.numeric( decimal, opts )( val, data, host );\n\t\t\tif ( numeric !== true ) {\n\t\t\t\treturn opts.message;\n\t\t\t}\n\n\t\t\t// val.toString() for '' is 0, which would mean it would always fail, even if empty values\n\t\t\t// are allowed.\n\t\t\tif (val === '' && opts.empty) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( decimal !== '.' ) {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\treturn val < min ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Check for a numeric input and that it is less than a given value.\n\t *\n\t * @static\n\t * @param {number} max Maximum value\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static maxNum( max: number, decimal: string = '.', cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet numeric = await Validator.numeric( decimal, opts )( val, data, host );\n\t\t\tif ( numeric !== true ) {\n\t\t\t\treturn opts.message;\n\t\t\t}\n\n\t\t\tif ( decimal !== '.' ) {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\treturn val > max ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Check for a numeric input and that it is in between two given values.\n\t *\n\t * @static\n\t * @param {number} min Minimum value\n\t * @param {number} max Maximum value\n\t * @param {string} [decimal='.'] Character to use as the decimal place\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minMaxNum(\n\t\tmin: number,\n\t\tmax: number,\n\t\tdecimal: string = '.',\n\t\tcfg: ValidationOptions | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet numeric = await Validator.numeric( decimal, opts )( val, data, host );\n\t\t\tif ( numeric !== true ) {\n\t\t\t\treturn opts.message;\n\t\t\t}\n\n\t\t\tif ( decimal !== '.' ) {\n\t\t\t\tval = val.toString().replace(decimal, '.');\n\t\t\t}\n\n\t\t\treturn val < min || val > max ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * String validation methods\n\t */\n\n\t/**\n\t * Validate an input as an e-mail address.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static email( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tlet re = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n\n\t\t\treturn re.test( val ) ?\n\t\t\t\ttrue :\n\t\t\t\topts.message;\n\t\t};\n\t}\n\n\t/**\n\t * Validate a string has a minimum length.\n\t *\n\t * @static\n\t * @param {number} min Minimum length\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minLen( min: number, cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\treturn val.length < min ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Validate a string is less or equal to a maximum length.\n\t *\n\t * @static\n\t * @param {number} max Maximum length\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static maxLen( max: number, cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\treturn val.length > max ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Require a string with a certain minimum or maximum number of characters.\n\t *\n\t * @static\n\t * @param {number} min Minimum length\n\t * @param {number} max Maximum length\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static minMaxLen( min: number, max: number, cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\treturn val.length < min || val.length > max ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Validate as an IP address.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static ip( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tlet a = val.split('.');\n\t\t\tif ( a.length !== 4 ) {\n\t\t\t\treturn opts.message;\n\t\t\t}\n\n\t\t\tfor ( let i = 0 ; i < 4 ; i++ ) {\n\t\t\t\tlet parsed = parseInt( a[i], 10 );\n\t\t\t\tif ( parsed !== a[i] * 1 ) {\n\t\t\t\t\treturn opts.message;\n\t\t\t\t}\n\n\t\t\t\tif ( parsed < 0 || parsed > 255 ) {\n\t\t\t\t\treturn opts.message;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/**\n\t * Validate as a URL.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static url( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\treturn ! validUrl.isWebUri( val ) ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Check if string could contain an XSS attack string\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static xss( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tlet field = host.field;\n\n\t\t\treturn field.xssSafety( val ) !== val ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Confirm that the value submitted is in a list of allowable values\n\t *\n\t * @static\n\t * @param {any[]} values List of values that are valid\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static values( values: any[], cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\treturn values.includes( val ) ?\n\t\t\t\ttrue :\n\t\t\t\topts.message;\n\t\t};\n\t}\n\n\t/**\n\t * Ensure that the submitted string does not contain HTML tags\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static noTags( cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\treturn val.toString().test(/<.*>/) ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t* Date validation methods\n\t*/\n\n\t/**\n\t * Check that a valid date input is given. Uses MomentJS\n\t *\n\t * @static\n\t * @param {string} format MomentJS date format\n\t * @param {string} [locale=null] MomentJS locale\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static dateFormat( format: string, locale: string | null = null, cfg: ValidationOptions | null = null ): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tlet res = locale ?\n\t\t\t\tmoment( val, format, locale, true ).isValid() :\n\t\t\t\tmoment( val, format, true ).isValid();\n\n\t\t\treturn ! res ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t* Database validation\n\t*/\n\n\t/**\n\t * Check that the given value is unique in the database\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @param {string} [column=null] Column name to use to check as a unique\n\t *   value. If not given the host field's database column name is used\n\t * @param {string} [table=null] Table to check that this value is uniquely\n\t *   valid on. If not given the host Editor's table name is used\n\t * @param {knex} [db=null] Database connection. If not given the host\n\t *   Editor's database connection is used\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static dbUnique(\n\t\tcfg: ValidationOptions | null = null,\n\t\tcolumn: string | null = null,\n\t\ttable: string | null = null,\n\t\tdb: knex | null = null\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tif ( db === null ) {\n\t\t\t\tdb = host.db;\n\t\t\t}\n\n\t\t\tif ( table === null ) {\n\t\t\t\ttable = host.editor.table()[0];\n\t\t\t}\n\n\t\t\tif ( column === null ) {\n\t\t\t\tcolumn = host.field.dbField();\n\t\t\t}\n\n\t\t\tlet q = db\n\t\t\t\t.table( table )\n\t\t\t\t.select( column )\n\t\t\t\t.where( { [column]: val } );\n\n\t\t\t// If doing an edit then we need to also discount the current row,\n\t\t\t// since it is of course already validly unique\n\t\t\tif ( host.action === 'edit' ) {\n\t\t\t\tlet cond = host.editor.pkeyToObject( host.id, true );\n\t\t\t\tq.whereNot( cond );\n\t\t\t}\n\n\t\t\tlet res = await q;\n\n\t\t\treturn res.length ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/**\n\t * Check that the given value is a value that is available in a database -\n\t * i.e. a join primary key. This will attempt to automatically use the table\n\t * name and value column from the field's `Options` method (under the\n\t * assumption that it will typically be used with a joined field), but the\n\t * table and field can also be specified via the options.\n\t *\n\t * @static\n\t * @param {ValidationOptions} [cfg=null] Validation options\n\t * @param {string} [column=null] Column name to use to check as a unique\n\t *   value. If not given the host field's database column name is used\n\t * @param {string} [table=null] Table to check that this value is uniquely\n\t *   valid on. If not given the host Editor's table name is used\n\t * @param {knex} [db=null] Database connection. If not given the host\n\t *   Editor's database connection is used\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static dbValues(\n\t\tcfg: ValidationOptions | null = null,\n\t\tcolumn: string | null = null,\n\t\ttable: string | null = null,\n\t\tdb: knex | null = null,\n\t\tvalues: any[] = []\n\t): IValidator {\n\t\tlet opts = ValidationOptions.select( cfg );\n\n\t\treturn async function( val: any, data: object, host: ValidationHost ): Promise<true|string> {\n\t\t\tlet common = Validator._common( val, opts );\n\t\t\tlet options = host.field.options();\n\n\t\t\tif ( common !== null ) {\n\t\t\t\treturn common === false ?\n\t\t\t\t\topts.message :\n\t\t\t\t\ttrue;\n\t\t\t}\n\n\t\t\tif ( values.indexOf(val) !== -1 ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif ( db === null ) {\n\t\t\t\tdb = host.db;\n\t\t\t}\n\n\t\t\tif ( table === null && options instanceof JoinOptions ) {\n\t\t\t\ttable = options.table();\n\t\t\t}\n\n\t\t\tif ( column === null && options instanceof JoinOptions ) {\n\t\t\t\tcolumn = options.value();\n\t\t\t}\n\n\t\t\tif ( table === null || column === null ) {\n\t\t\t\tthrow new Error( 'Table or column for database value check is not ' +\n\t\t\t\t\t'defined for field ' + host.field.name()\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tlet res = await db( table )\n\t\t\t\t.select( column )\n\t\t\t\t.where( { [column]: val } );\n\n\t\t\treturn ! res || ! res.length ?\n\t\t\t\topts.message :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t* File upload validators\n\t*/\n\n\t/**\n\t * Check that the uploaded file has a given extension\n\t *\n\t * @static\n\t * @param {string[]} extns Allowed extensions\n\t * @param {string} msg Error message to return if not valid\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static fileExtensions( extns: string[], msg: string ): IFileValidator {\n\t\treturn async function( file: IFile ) {\n\t\t\tfor ( let i = 0, ien = extns.length; i < ien; i++ ) {\n\t\t\t\tif ( file.extn.toLowerCase() === extns[i].toLowerCase() ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn msg;\n\t\t};\n\t}\n\n\t/**\n\t * Check that the uploaded file is equal or less than a given size.\n\t *\n\t * @static\n\t * @param {string[]} size Max file size in bytes\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static fileSize( size: number, msg: string ): IFileValidator {\n\t\treturn async function( file: IFile ) {\n\t\t\treturn file.size > size ?\n\t\t\t\tmsg :\n\t\t\t\ttrue;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t* Mjoin validators\n\t*/\n\n\t/**\n\t * Require a minimum value of the number of options / values submitted in\n\t * an array\n\t *\n\t * @static\n\t * @param size Min array size required to be valid\n\t * @param msg Error message\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static mjoinMinCount( size: number, msg: string ): IMjoinValidator {\n\t\treturn async function( editor: Editor, action: string, data: any[] ) {\n\t\t\tif ( action === 'create'  || action === 'edit' ) {\n\t\t\t\treturn data.length < size ?\n\t\t\t\t\tmsg :\n\t\t\t\t\ttrue;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/**\n\t * Require a maximum value of the number of options / values submitted in\n\t * an array\n\t *\n\t * @static\n\t * @param size Max array size required to be valid\n\t * @param msg Error message\n\t * @returns {IValidator} Configured validation function\n\t */\n\tpublic static mjoinMaxCount( size: number, msg: string ): IMjoinValidator {\n\t\treturn async function( editor: Editor, action: string, data: any[] ) {\n\t\t\tif ( action === 'create'  || action === 'edit' ) {\n\t\t\t\treturn data.length > size ?\n\t\t\t\t\tmsg :\n\t\t\t\t\ttrue;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t* Internal methods\n\t*/\n\n\tprivate static _common( val: any, opts: ValidationOptions ): boolean|null {\n\t\t// Error state tests\n\t\tif ( !opts.optional && val === null ) {\n\t\t\t// Value must be given\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( val !== null && opts.empty === false && val === '' ) {\n\t\t\t// Value must not be empty\n\t\t\treturn false;\n\t\t}\n\n\t\t// Validate passed states\n\t\tif ( opts.optional && val === null ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( opts.empty === true && val === '' ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Have the specific validation function perform its tests\n\t\treturn null;\n\t}\n}\n"]}