{"version":3,"sources":["editor.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAE7B,OAAO,KAAgB,MAAM,SAAS,CAAC;AAEvC,OAAO,KAAK,MAAM,SAAS,CAAC;AAC5B,OAAO,UAAU,MAAM,cAAc,CAAC;AACtC,OAAO,EAAC,OAAO,EAAC,MAAM,UAAU,CAAC;AAGjC;;;;GAIG;AACH,oBAAY,MAAM;IACjB,qCAAqC;IACrC,IAAI,IAAA;IAEJ,wBAAwB;IACxB,MAAM,IAAA;IAEN,6BAA6B;IAC7B,IAAI,IAAA;IAEJ,+BAA+B;IAC/B,MAAM,IAAA;IAEN,qBAAqB;IACrB,MAAM,IAAA;CACN;AAED;;;GAGG;AACH,MAAM,WAAW,QAAQ;IACxB,mCAAmC;IACnC,EAAE,CAAC,EAAE,MAAM,CAAC;IAEZ,2BAA2B;IAC3B,IAAI,EAAE,MAAM,CAAC;IAEb,4BAA4B;IAC5B,MAAM,EAAE,MAAM,CAAC;CACf;AAED;;;GAGG;AACH,MAAM,WAAW,QAAQ;IACxB,yBAAyB;IACzB,GAAG,EAAE,KAAK,GAAG,MAAM,CAAC;IAEpB,+BAA+B;IAC/B,MAAM,EAAE,MAAM,CAAC;CACf;AAED;;;GAGG;AACH,MAAM,WAAW,SAAS;IACzB,sCAAsC;IACtC,IAAI,EAAE,MAAM,CAAC;IAEb,uBAAuB;IAEvB,UAAU,EAAE,OAAO,CAAC;IAEpB,iCAAiC;IACjC,MAAM,EAAE;QACP,qBAAqB;QACrB,KAAK,EAAE,MAAM,CAAC;KACd,CAAC;CACF;AAED;;;;GAIG;AACH,MAAM,WAAW,UAAU;IAC1B,uCAAuC;IACvC,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB,2DAA2D;IAC3D,IAAI,CAAC,EAAE,MAAM,EAAE,CAAC;IAEhB,qCAAqC;IACrC,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd,2CAA2C;IAC3C,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf,sCAAsC;IACtC,MAAM,CAAC,EAAE,MAAM,CAAC;IAEhB,iCAAiC;IACjC,KAAK,CAAC,EAAE,QAAQ,EAAE,CAAC;IAEnB,2CAA2C;IAC3C,OAAO,CAAC,EAAE,SAAS,EAAE,CAAC;IAEtB,4CAA4C;IAC5C,MAAM,CAAC,EAAE;QACR,KAAK,EAAE,MAAM,CAAC;KACd,CAAC;IAEF,kCAAkC;IAClC,WAAW,CAAC,EAAE,MAAM,CAAC;CACrB;AAED;;;GAGG;AACH,MAAM,WAAW,WAAW;IAC3B,6CAA6C;IAC7C,IAAI,CAAC,EAAE,MAAM,EAAE,CAAC;IAEhB,oDAAoD;IACpD,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC;IAErB,oDAAoD;IACpD,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf,yCAAyC;IACzC,WAAW,CAAC,EAAE,QAAQ,EAAE,CAAC;IAEzB,yDAAyD;IACzD,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB,iCAAiC;IACjC,KAAK,CAAC,EAAE,MAAM,CAAC;IAEf,qCAAqC;IACrC,IAAI,CAAC,EAAE,MAAM,CAAC;IAEd,4DAA4D;IAC5D,YAAY,CAAC,EAAE,MAAM,CAAC;IAEtB,0DAA0D;IAC1D,eAAe,CAAC,EAAE,MAAM,CAAC;IAEzB,2CAA2C;IAC3C,WAAW,CAAC,EAAE,GAAG,CAAC;IAClB,wCAAwC;IACxC,MAAM,CAAC,EAAE;QACR,EAAE,EAAE,MAAM,CAAA;KACV,CAAC;IAEF,qDAAqD;IACrD,KAAK,CAAC,EAAE,GAAG,EAAE,CAAC;CACd;AAED;;;;GAIG;AACH,oBAAY,gBAAgB,GAC3B,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,UAAU,KAAK,OAAO,CAAC,IAAI,GAAG,MAAM,CAAC,CAAC;AAyB9E;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAM,CAAC,OAAO,OAAO,MAAO,SAAQ,UAAU;IAC7C,OAAc,MAAM,gBAAU;IAE9B,OAAc,OAAO,EAAE,MAAM,CAAW;IAExC;;;;;;;;OAQG;WACW,MAAM,CAAC,IAAI,EAAE,UAAU,GAAG,MAAM;IAuB9C,OAAO,CAAC,GAAG,CAAO;IAClB,OAAO,CAAC,OAAO,CAAe;IAC9B,OAAO,CAAC,SAAS,CAAC;IAClB,OAAO,CAAC,YAAY,CAAC;IACrB,OAAO,CAAC,SAAS,CAAkB;IACnC,OAAO,CAAC,KAAK,CAAe;IAC5B,OAAO,CAAC,KAAK,CAAoB;IACjC,OAAO,CAAC,MAAM,CAAgB;IAC9B,OAAO,CAAC,eAAe,CAAgB;IACvC,OAAO,CAAC,YAAY,CAAkB;IACtC,OAAO,CAAC,MAAM,CAAM;IACpB,OAAO,CAAC,SAAS,CAAmB;IACpC,OAAO,CAAC,IAAI,CAAmB;IAC/B,OAAO,CAAC,OAAO,CAAM;IACrB,OAAO,CAAC,WAAW,CAA0B;IAC7C,OAAO,CAAC,SAAS,CAAkB;IACnC,OAAO,CAAC,gBAAgB,CAAO;IAC/B,OAAO,CAAC,WAAW,CAAU;IAC7B,OAAO,CAAC,MAAM,CAAkB;IAChC,OAAO,CAAC,UAAU,CAAa;IAC/B,OAAO,CAAC,eAAe,CAAkB;IACzC,OAAO,CAAC,OAAO,CAAgB;IAC/B,OAAO,CAAC,MAAM,CAAiB;IAC/B,OAAO,CAAC,WAAW,CAAiB;IAEpC;;;;;;;;OAQG;gBACS,EAAE,GAAE,IAAW,EAAE,KAAK,GAAE,MAAM,GAAG,MAAM,EAAS,EAAE,IAAI,GAAE,MAAM,GAAG,MAAM,EAAS;IAgB5F;;;OAGG;IACI,IAAI,IAAI,WAAW;IAI1B;;;OAGG;IACI,EAAE,IAAI,IAAI;IACjB;;;;OAIG;IACI,EAAE,CAAC,EAAE,EAAE,IAAI,GAAG,MAAM;IAoB3B,kCAAkC;IAC3B,aAAa,IAAI,IAAI;IAI5B;;;OAGG;IACI,KAAK,IAAI,OAAO;IACvB;;;;OAIG;IACI,KAAK,CAAC,GAAG,EAAE,OAAO,GAAG,MAAM;IAClC;;;;OAIG;IACI,KAAK,CAAC,OAAO,EAAE,GAAG,GAAG,MAAM;IAgBlC;;OAEG;IACI,UAAU,IAAI,OAAO;IAC5B;;;;;OAKG;IACI,UAAU,CAAC,UAAU,EAAE,OAAO,GAAG,MAAM;IAU9C;;;;OAIG;IACI,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,MAAM;IAClC;;;;OAIG;IACI,KAAK,CAAC,IAAI,EAAE,MAAM,GAAG,KAAK;IAgBjC;;;OAGG;IACI,MAAM,IAAI,KAAK,EAAE;IACxB;;;;OAIG;IACI,MAAM,CAAC,GAAG,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM;IAWzC;;;;;;;;;OASG;IACI,QAAQ,IAAI,MAAM;IACzB;;;;OAIG;IACI,QAAQ,CAAC,QAAQ,EAAE,MAAM,GAAG,MAAM;IAUzC;;;;;OAKG;IACI,MAAM,IAAI,UAAU;IAI3B;;;;;;;;;;;;OAYG;IACI,IAAI,IAAI,KAAK,EAAE;IACtB;;;;OAIG;IACI,IAAI,CAAC,GAAG,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM;IAWrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA+BG;IACI,QAAQ,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,GAAG,MAAM;IAWxF;;;OAGG;IACI,cAAc,IAAI,OAAO;IAChC;;;;;;OAMG;IACI,cAAc,CAAC,MAAM,EAAE,OAAO,GAAG,MAAM;IAU9C;;;;;;;OAOG;IACI,EAAE,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,GAAG,MAAM;IAUnD;;;;;;;OAOG;IACI,MAAM,IAAI,MAAM;IACvB;;;;OAIG;IACI,MAAM,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM;IAUrC;;;OAGG;IACI,SAAS,IAAI,MAAM,EAAE;IAC5B;;;;;;;OAOG;IACI,SAAS,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,MAAM;IAgBlD;;;;;;;;;OASG;IACI,KAAK,IAAI,MAAM,EAAE;IACxB;;;;OAIG;IACI,KAAK,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,MAAM;IAgB9C;;;;;;;;OAQG;IACI,WAAW,IAAI,OAAO;IAC7B;;;;OAIG;IACI,WAAW,CAAC,WAAW,EAAE,OAAO,GAAG,MAAM;IAUhD;;;;;;OAMG;IACI,IAAI,IAAI,MAAM,EAAE;IACvB;;;;;OAKG;IACI,IAAI,CAAC,IAAI,EAAE,MAAM,GAAG,MAAM,EAAE,GAAG,MAAM;IAiB5C;;;;;;;OAOG;IACI,WAAW,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,GAAE,OAAe,GAAG,MAAM;IAkC9D;;;;;;;;OAQG;IACI,YAAY,CAAC,KAAK,EAAE,MAAM,EAAE,IAAI,GAAE,OAAe,EAAE,IAAI,GAAE,MAAM,EAAS,GAAG,MAAM;IA0BxF;;;;;;;;OAQG;IACU,OAAO,CAAC,IAAI,EAAE,UAAU,EAAE,KAAK,GAAE,OAAc,GAAG,OAAO,CAAC,MAAM,CAAC;IA6C9E;;;;;;;OAOG;IACI,QAAQ,IAAI,OAAO;IAC1B;;;;OAIG;IACI,QAAQ,CAAC,QAAQ,EAAE,OAAO,GAAG,MAAM;IAU1C;;;;;;;;;;;;;;OAcG;IACU,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAE,EAAE,IAAI,EAAE,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC;IAyC7E;;;OAGG;IACI,SAAS,IAAI,gBAAgB,EAAE;IACtC;;;;;OAKG;IACI,SAAS,CAAC,EAAE,EAAE,gBAAgB,GAAG,MAAM;IAU9C;;;OAGG;IACI,KAAK,IAAI,GAAG,EAAE;IACrB;;;;;;OAMG;IACI,KAAK,CAAC,GAAG,IAAI,EAAE,GAAG,EAAE,GAAG,MAAM;IAWpC;;;OAGG;IACI,UAAU,IAAI,IAAI;IAMzB;;;MAGE;IACQ,KAAK,CAAC,QAAQ,KAAA;YAgBV,UAAU;YAmBV,SAAS;YA8BT,eAAe;IAuD7B,OAAO,CAAC,UAAU;YAqBJ,IAAI;IAgIlB,OAAO,CAAC,SAAS;YAQH,OAAO;YAgCP,eAAe;YA8Ef,oBAAoB;IAyFlC,OAAO,CAAC,MAAM;IAkBd,OAAO,CAAC,KAAK;IA+Bb,OAAO,CAAC,SAAS;IA8BjB,OAAO,CAAC,gBAAgB;IAUxB,OAAO,CAAC,cAAc;IAMtB,OAAO,CAAC,gBAAgB;IAgBxB,OAAO,CAAC,mBAAmB;YAsBb,QAAQ;IAkJtB,OAAO,CAAC,UAAU;YAMJ,OAAO;YAqEP,YAAY;YA6CZ,IAAI;IA0ClB,OAAO,CAAC,SAAS;IAgBjB,OAAO,CAAC,UAAU;IA4DlB,OAAO,CAAC,SAAS;IAQjB,OAAO,CAAC,QAAQ;YAWF,QAAQ;YAqBR,OAAO;YAuBP,OAAO;CA+DrB","file":"editor.d.ts","sourcesContent":["import * as crc from 'crc';\nimport * as knex from 'knex';\n\nimport Field, {SetType} from './field';\nimport Format from './formatters';\nimport Mjoin from './mjoin';\nimport NestedData from './nestedData';\nimport {IUpload} from './upload';\nimport Validate from './validators';\n\n/**\n * Action that has been requested by the client-side\n * (based on the `action` parameter).\n * @export\n */\nexport enum Action {\n\t/** Get data (used by DataTables). */\n\tRead,\n\n\t/** Create a new row. */\n\tCreate,\n\n\t/** Edit one or more rows. */\n\tEdit,\n\n\t/** Delete one or more rows. */\n\tDelete,\n\n\t/** Upload a file. */\n\tUpload\n}\n\n/**\n * Field error object.\n * @export\n */\nexport interface IDtError {\n\t/** Row id that caused the error */\n\tid?: string;\n\n\t/** Field name in error. */\n\tname: string;\n\n\t/** Error message string. */\n\tstatus: string;\n}\n\n/**\n * DataTables request's order object.\n * @export\n */\nexport interface IDtOrder {\n\t/** Sorting direction. */\n\tdir: 'asc' | 'desc';\n\n\t/** Column index to sort by. */\n\tcolumn: number;\n}\n\n/**\n * DataTables request's column information object.\n * @export\n */\nexport interface IDtColumn {\n\t/** Data property (`columns.data`). */\n\tdata: string;\n\n\t/** Searchable flag. */\n\n\tsearchable: boolean;\n\n\t/** Search information object. */\n\tsearch: {\n\t\t/** Search string. */\n\t\tvalue: string;\n\t};\n}\n\n/**\n * DataTables request object. This is the information that DataTables\n * and Editor can send to the server.\n * @export\n */\nexport interface IDtRequest {\n\t/** Editor - Action being requested. */\n\taction?: string;\n\n\t/** Editor - Data being sent for create / edit / delete. */\n\tdata?: object[];\n\n\t/** DataTables SSP - Draw counter. */\n\tdraw?: number;\n\n\t/** DataTables SSP - paging start point. */\n\tstart?: number;\n\n\t/** DataTables SSP - paging length. */\n\tlength?: number;\n\n\t/** DataTables SSP - ordering. */\n\torder?: IDtOrder[];\n\n\t/** DataTables SSP - column information. */\n\tcolumns?: IDtColumn[];\n\n\t/** DataTables SSP - Global search value. */\n\tsearch?: {\n\t\tvalue: string;\n\t};\n\n\t/** Editor - Upload field name. */\n\tuploadField?: string;\n}\n\n/**\n * Response object for DataTables and Editor\n * @export\n */\nexport interface IDtResponse {\n\t/** DataTables - Array of row information. */\n\tdata?: object[];\n\n\t/** Editor - Rows which have not been acted upon. */\n\tcancelled?: string[];\n\n\t/** DataTables and Editor - General error string. */\n\terror?: string;\n\n\t/** Editor - Field information errors. */\n\tfieldErrors?: IDtError[];\n\n\t/** Editor - `select`, `radio` and `checkbox` options. */\n\toptions?: object;\n\n\t/** Editor - file information. */\n\tfiles?: object;\n\n\t/** DataTables SSP - draw counter. */\n\tdraw?: number;\n\n\t/** DataTables SSP - number of records in the result set. */\n\trecordsTotal?: number;\n\n\t/** DataTables SSP - number of records after filtering. */\n\trecordsFiltered?: number;\n\n\t/** DataTables SSP - SearchPanes Options */\n\tsearchPanes?: any;\n\t/** Editor - Upload complete file id. */\n\tupload?: {\n\t\tid: string\n\t};\n\n\t/** Debug information if enabled by Editor.debug() */\n\tdebug?: any[];\n}\n\n/**\n * Global validation is performed when Editor submits a create, edit or\n * delete request. The function can be useful for cases where fields must\n * be validates together, rather than individually.\n */\nexport type IGlobalValidator =\n\t(editor: Editor, action: string, http: IDtRequest) => Promise<true | string>;\n\n/**\n * Server-side processing object structure\n * @interface ISSP\n * @private\n */\ninterface ISSP {\n\tdraw?: number;\n\trecordsFiltered?: number;\n\trecordsTotal?: number;\n}\n\n/**\n * Left join object structure\n * @interface ILeftJoin\n * @private\n */\ninterface ILeftJoin {\n\ttable: string;\n\tfield1: string;\n\tfield2: string;\n\toperator: string;\n}\n\n/**\n * DataTables Editor base class for creating editable tables.\n *\n * Editor class instances are capable of servicing all of the requests that\n * DataTables and Editor will make from the client-side - specifically:\n *\n * * Get data\n * * Create new record\n * * Edit existing record\n * * Delete existing records\n *\n * The Editor instance is configured with information regarding the\n * database table fields that you which to make editable, and other information\n * needed to read and write to the database (table name for example!).\n *\n * This documentation is very much focused on describing the API presented\n * by these DataTables Editor classes. For a more general overview of how\n * the Editor class is used, and how to install Editor on your server, please\n * refer to the {@link http://editor.datatables.net/manual Editor manual}.\n *\n * @export\n * @class Editor\n * @extends {NestedData}\n */\nexport default class Editor extends NestedData {\n\tpublic static Action = Action;\n\n\tpublic static version: string = '1.9.6';\n\n\t/**\n\t * Determine the request type from an HTTP request.\n\t *\n\t * @static\n\t * @param {IDtRequest} http HTTP request - normally `request.body`. Note that\n\t *   if you are using `body-parser` you should use `{ extended: true }` as its\n\t *   options to ensure that nested properties are correctly resolved.\n\t * @returns {Action} Indicates what action the request is\n\t */\n\tpublic static action(http: IDtRequest): Action {\n\t\tif (! http || ! http.action) {\n\t\t\treturn Action.Read;\n\t\t}\n\n\t\tswitch (http.action) {\n\t\t\tcase 'create':\n\t\t\t\treturn Action.Create;\n\n\t\t\tcase 'edit':\n\t\t\t\treturn Action.Edit;\n\n\t\t\tcase 'remove':\n\t\t\t\treturn Action.Delete;\n\n\t\t\tcase 'upload':\n\t\t\t\treturn Action.Upload;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown Editor action: ' + http.action);\n\t\t}\n\t}\n\n\tprivate _db: knex;\n\tprivate _fields: Field[] = [];\n\tprivate _formData;\n\tprivate _processData;\n\tprivate _idPrefix: string = 'row_';\n\tprivate _join: Mjoin[] = [];\n\tprivate _pkey: string[] = ['id'];\n\tprivate _table: string[] = [];\n\tprivate _readTableNames: string[] = [];\n\tprivate _transaction: boolean = false;\n\tprivate _where = [];\n\tprivate _leftJoin: ILeftJoin[] = [];\n\tprivate _out: IDtResponse = {};\n\tprivate _events = [];\n\tprivate _validators: IGlobalValidator[] = [];\n\tprivate _tryCatch: boolean = false;\n\tprivate _knexTransaction: knex;\n\tprivate _uploadData: IUpload;\n\tprivate _debug: boolean = false;\n\tprivate _debugInfo: any[] = [];\n\tprivate _leftJoinRemove: boolean = false;\n\tprivate _schema: string = null;\n\tprivate _write: boolean = true;\n\tprivate _doValidate: boolean = true;\n\n\t/**\n\t * Creates an instance of Editor.\n\t * @param {knex} [db=null] Database connection object\n\t * @param {(string|string[])} [table=null] The table name in the database to\n\t *   read and write information from and to. Can be given here or with the\n\t *   'table' method.\n\t * @param {(string|string[])} [pkey=null] Primary key column name in the\n\t *   table given in\n\t */\n\tconstructor(db: knex = null, table: string | string[] = null, pkey: string | string[] = null) {\n\t\tsuper();\n\n\t\tif (db) {\n\t\t\tthis.db(db);\n\t\t}\n\n\t\tif (table) {\n\t\t\tthis.table(table);\n\t\t}\n\n\t\tif (pkey) {\n\t\t\tthis.pkey(pkey);\n\t\t}\n\t}\n\n\t/**\n\t * Get the data constructed in this instance.\n\t * @returns {IDtResponse} Data object\n\t */\n\tpublic data(): IDtResponse {\n\t\treturn this._out;\n\t}\n\n\t/**\n\t * Get the database connection assigned to the instance.\n\t * @returns {knex} Knex db interface\n\t */\n\tpublic db(): knex;\n\t/**\n\t * Set the database connection.\n\t * @param {knex} Knex db interface\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic db(db: knex): Editor;\n\tpublic db(db?: knex): any {\n\t\tif (db === undefined) {\n\t\t\tif (this._knexTransaction) {\n\t\t\t\treturn this._schema\n\t\t\t\t\t? this._knexTransaction.withSchema(this._schema)\n\t\t\t\t\t: this._knexTransaction;\n\t\t\t}\n\t\t\telse if (this._schema) {\n\t\t\t\treturn this._db.withSchema(this._schema);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this._db;\n\t\t\t}\n\t\t}\n\n\t\tthis._db = db;\n\t\treturn this;\n\t}\n\n\t/** Get the current transaction */\n\tpublic dbTransaction(): knex {\n\t\treturn this._knexTransaction;\n\t}\n\n\t/**\n\t * Get the debug setting for this instance\n\t * @returns {boolean} Debug enabled (true) or not\n\t */\n\tpublic debug(): boolean;\n\t/**\n\t * Set the debug setting for this instance\n\t * @param {boolean} set Debug flag\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic debug(set: boolean): Editor;\n\t/**\n\t * Add a debug message\n\t * @param {any} message Message to add\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic debug(message: any): Editor;\n\tpublic debug(param?: any): any {\n\t\tif (param === undefined) {\n\t\t\treturn this._debug;\n\t\t}\n\t\telse if (param === true || param === false) {\n\t\t\tthis._debug = param;\n\t\t\treturn this;\n\t\t}\n\n\t\t// Otherwise its a message\n\t\tthis._debugInfo.push(param);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the validate flag\n\t */\n\tpublic doValidate(): boolean;\n\t/**\n\t * Enable / disable validation. This would be used with after the\n\t * `validate` method if you call that before `process()`.\n\t * @param {boolean} doValidate true (default) = perform validation, false don't.\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic doValidate(doValidate: boolean): Editor;\n\tpublic doValidate(doValidate?: boolean): any {\n\t\tif (doValidate === undefined) {\n\t\t\treturn this._doValidate;\n\t\t}\n\n\t\tthis._doValidate = doValidate;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a new field to the Editor instance\n\t * @param field Field instance to add=\n\t * @returns {Editor} Editor instance\n\t */\n\tpublic field(field: Field): Editor;\n\t/**\n\t * Get a field\n\t * @param name Field name to get\n\t * @returns {Field} Field instance\n\t */\n\tpublic field(name: string): Field;\n\tpublic field(nameOrField: any): any {\n\t\tif (typeof nameOrField === 'string') {\n\t\t\tfor (let i = 0, ien = this._fields.length; i < ien; i++) {\n\t\t\t\tif (this._fields[i].name() === nameOrField) {\n\t\t\t\t\treturn this._fields[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new Error('Unknown field: ' + nameOrField);\n\t\t}\n\n\t\tthis._fields.push(nameOrField);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the fields assigned to this instance.\n\t * @returns {Field[]} Array of fields\n\t */\n\tpublic fields(): Field[];\n\t/**\n\t * Add one or more fields to the instance.\n\t * @param {...Field[]} fields Fields to add\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic fields(...fields: Field[]): Editor;\n\tpublic fields(...fields: Field[]): any {\n\t\tif (fields === undefined || fields.length === 0) {\n\t\t\treturn this._fields;\n\t\t}\n\n\t\tthis._fields.push.apply(this._fields, fields);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the id prefix.\n\t *\n\t * Typically primary keys are numeric and this is not a valid ID value in an\n\t * HTML document - is also increases the likelihood of an ID clash if multiple\n\t * tables are used on a single page. As such, a prefix is assigned to the\n\t * primary key value for each row, and this is used as the DOM ID, so Editor\n\t * can track individual rows.\n\t * @returns {string} id prefix\n\t */\n\tpublic idPrefix(): string;\n\t/**\n\t * Get the id prefix.\n\t * @param {string} idPrefix Prefix to use.\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic idPrefix(idPrefix: string): Editor;\n\tpublic idPrefix(idPrefix?: string): any {\n\t\tif (idPrefix === undefined) {\n\t\t\treturn this._idPrefix;\n\t\t}\n\n\t\tthis._idPrefix = idPrefix;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the data that is being processed by the Editor instance. This is only\n\t * useful once the `process()` method has been called, and is available for\n\t * use in validation and formatter methods.\n\t * @returns {IDtRequest} Data that has been passed into {@link Editor.process()}\n\t */\n\tpublic inData(): IDtRequest {\n\t\treturn this._processData;\n\t}\n\n\t/**\n\t * Get the configured Mjoin instances.\n\t *\n\t * Note that for the majority of use cases you will want to use the\n\t * `leftJoin()` method. It is significantly easier to use if you are just\n\t * doing a simple left join!\n\t *\n\t * The list of Join instances that Editor will join the parent table to\n\t * (i.e. the one that the {@link Editor.table} and {@link Editor.fields}\n\t * methods refer to in this class instance).\n\t *\n\t * @returns {Mjoin[]} Array of Mjoin instances\n\t */\n\tpublic join(): Mjoin[];\n\t/**\n\t * Add one or more Mjoin instances.\n\t * @param {...Mjoin[]} join Mjoin instance to add.\n\t * @returns {Editor} Self for chaining.\n\t */\n\tpublic join(...join: Mjoin[]): Editor;\n\tpublic join(...join: Mjoin[]): any {\n\t\tif (join === undefined || join.length === 0) {\n\t\t\treturn this._join;\n\t\t}\n\n\t\tthis._join.push.apply(this._join, join);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a left join condition to the Editor instance, allowing it to operate\n\t * over multiple tables. Multiple `leftJoin()` calls can be made for a\n\t * single Editor instance to join multiple tables.\n\t *\n\t * A left join is the most common type of join that is used with Editor\n\t * so this method is provided to make its use very easy to configure. Its\n\t * parameters are basically the same as writing an SQL left join statement,\n\t * but in this case Editor will handle the create, update and remove\n\t * requirements of the join for you:\n\t *\n\t * * Create - On create Editor will insert the data into the primary table\n\t *   and then into the joined tables - selecting the required data for each\n\t *   table.\n\t * * Edit - On edit Editor will update the main table, and then either\n\t *   update the existing rows in the joined table that match the join and\n\t *   edit conditions, or insert a new row into the joined table if required.\n\t * * Remove - On delete Editor will remove the main row and then loop over\n\t *   each of the joined tables and remove the joined data matching the join\n\t *   link from the main table.\n\t *\n\t * Please note that when using join tables, Editor requires that you fully\n\t * qualify each field with the field's table name. SQL can result table\n\t * names for ambiguous field names, but for Editor to provide its full CRUD\n\t * options, the table name must also be given. For example the field\n\t * `first_name` in the table `users` would be given as `users.first_name`.\n\t * @param {string} table Table name to do a join onto\n\t * @param {string} field1 Field from the parent table to use as the join link\n\t * @param {string} operator Join condition (`=`, '<`, etc)\n\t * @param {string} field2 Field from the child table to use as the join link\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic leftJoin(table: string, field1: string, operator: string, field2: string): Editor {\n\t\tthis._leftJoin.push({\n\t\t\tfield1,\n\t\t\tfield2,\n\t\t\toperator,\n\t\t\ttable,\n\t\t});\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the left join remove value.\n\t * @returns {boolean} Value\n\t */\n\tpublic leftJoinRemove(): boolean;\n\t/**\n\t * Indicate if a remove should be performed on left joined tables when deleting\n\t * from the parent row. Note that this is disabled by default and will be\n\t * removed completely in v2. Use `ON DELETE CASCADE` in your database instead.\n\t * @param {boolean} remove Value\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic leftJoinRemove(remove: boolean): Editor;\n\tpublic leftJoinRemove(remove?: boolean): any {\n\t\tif (remove === undefined) {\n\t\t\treturn this._leftJoinRemove;\n\t\t}\n\n\t\tthis._leftJoinRemove = remove;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event listener. The `Editor` class will trigger an number of\n\t * events that some action can be taken on.\n\t * @param {string} name Event name\n\t * @param {Function} callback Event callback function that will be executed\n\t *   when the event occurs.\n\t * @returns {Editor} Self for chaining.\n\t */\n\tpublic on(name: string, callback: Function): Editor {\n\t\tif (! this._events[ name ]) {\n\t\t\tthis._events[ name ] = [];\n\t\t}\n\n\t\tthis._events[ name ].push(callback);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the database schema.\n\t *\n\t * This is used if you are using multiple schema's in your database. By default Editor\n\t * will not specify a schema, so the default search path will be used. This allows that\n\t * to be overridden.\n\t * @returns {string} Schema\n\t */\n\tpublic schema(): string;\n\t/**\n\t * Set the database schema\n\t * @param {string} schema Schema to use.\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic schema(schema: string): Editor;\n\tpublic schema(schema?: string): any {\n\t\tif (schema === undefined) {\n\t\t\treturn this._schema;\n\t\t}\n\n\t\tthis._schema = schema;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get CRUD read table name.\n\t * @returns {string[]} Configured read table name\n\t */\n\tpublic readTable(): string[];\n\t/**\n\t * Set CRUD read table name. If this method is used, Editor will create from the\n\t * table name(s) given rather than those given by `Editor->table()`. This can be\n\t * a useful distinction to allow a read from a VIEW (which could make use of a\n\t * complex SELECT) while writing to a different table.\n\t * @param {(string|string[])} table Database table name to use for reading from\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic readTable(table: string | string[]): Editor;\n\tpublic readTable(table?: string | string[]): any {\n\t\tif (table === undefined || table.length === 0) {\n\t\t\treturn this._readTableNames;\n\t\t}\n\n\t\tif (typeof table === 'string') {\n\t\t\tthis._readTableNames.push(table);\n\t\t}\n\t\telse {\n\t\t\tthis._readTableNames.push.apply(this._readTableNames, table);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the table name.\n\t *\n\t * The table name designated which DB table Editor will use as its data\n\t * source for working with the database. Table names can be given with an\n\t * alias, which can be used to simplify larger table names. The field\n\t * names would also need to reflect the alias, just like an SQL query. For\n\t * example: `users as a`.\n\t * @returns {string[]} Configured table name\n\t */\n\tpublic table(): string[];\n\t/**\n\t * Set the table name.\n\t * @param {(string|string[])} table Database table name to use\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic table(table: string | string[]): Editor;\n\tpublic table(table?: string | string[]): any {\n\t\tif (table === undefined || table.length === 0) {\n\t\t\treturn this._table;\n\t\t}\n\n\t\tif (typeof table === 'string') {\n\t\t\tthis._table.push(table);\n\t\t}\n\t\telse {\n\t\t\tthis._table.push.apply(this._table, table);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get transaction support status\n\t *\n\t * When enabled (which it is by default) Editor will use an SQL transaction\n\t * to ensure data integrity while it is performing operations on the table.\n\t * This can be optionally disabled using this method, if required by your\n\t * database configuration.\n\t * @returns {boolean} true is transactions are enabled, false otherwise.\n\t */\n\tpublic transaction(): boolean;\n\t/**\n\t * Set transaction support state\n\t * @param {boolean} transaction Set the transaction status\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic transaction(transaction: boolean): Editor;\n\tpublic transaction(transaction?: boolean): any {\n\t\tif (transaction === undefined) {\n\t\t\treturn this._transaction;\n\t\t}\n\n\t\tthis._transaction = transaction;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the primary key value.\n\t *\n\t * The primary key must be known to Editor so it will know which rows are being\n\t * edited / deleted upon those actions. The default value is ['id'].\n\t * @returns {string[]} Array of column names\n\t */\n\tpublic pkey(): string[];\n\t/**\n\t * Set the primary key value(s)\n\t * @param {string|string[]} [pkey] Primary key column name. Use an array of\n\t *   strings if using a compound key.\n\t * @returns {Editor} Self for chaining.\n\t */\n\tpublic pkey(pkey: string | string[]): Editor;\n\tpublic pkey(pkey?: string | string[]): any {\n\t\tif (pkey === undefined) {\n\t\t\treturn this._pkey;\n\t\t}\n\n\t\tif (typeof pkey === 'string') {\n\n\t\t\tthis._pkey = [ pkey ];\n\t\t}\n\t\telse {\n\t\t\tthis._pkey = pkey;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Convert a primary key array of field values to a combined value.\n\t * @param {object} row The row of data that the primary key value should\n\t *   be extracted from.\n\t * @param {boolean} [flat=false] Flag to indicate if the given array is flat\n\t *   (useful for `where` conditions) or nested for join tables.\n\t * @returns {string} The created primary key value.\n\t */\n\tpublic pkeyToValue(row: object, flat: boolean = false): string {\n\t\tlet pkey = this.pkey();\n\t\tlet id = [];\n\t\tlet val;\n\n\t\tfor (let i = 0, ien = pkey.length; i < ien; i++) {\n\t\t\tlet column = pkey[i];\n\n\t\t\tif (flat) {\n\t\t\t\tval = row[ column ] !== undefined ?\n\t\t\t\t\trow[ column ] :\n\t\t\t\t\tnull;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tval = this._readProp(column, row);\n\t\t\t}\n\n\t\t\tif (val === null) {\n\t\t\t\tthrow new Error('Primary key element is not available in the data set');\n\t\t\t}\n\n\t\t\t// Postgres gives a `Date` object for timestamps which causes issues as\n\t\t\t// a value, so convert it to be a string. Could also be done with setTypeParser\n\t\t\t// https://github.com/brianc/node-postgres/issues/1200\n\t\t\tif (val instanceof Date) {\n\t\t\t\tval = val.toISOString();\n\t\t\t}\n\n\t\t\tid.push(val);\n\t\t}\n\n\t\treturn id.join(this._pkeySeparator());\n\t}\n\n\t/**\n\t * Convert a primary key combined value to an array of field values.\n\t * @param {string} value The id that should be split apart\n\t * @param {boolean} [flat=false] Flag to indicate if the returned array should be\n\t *   flat (useful for `where` conditions) or nested for join tables.\n\t * @param {string[]} [pkey=null] The primary key name - will use the instance value\n\t *   if not given\n\t * @returns {object} Array of field values that the id was made up of\n\t */\n\tpublic pkeyToObject(value: string, flat: boolean = false, pkey: string[] = null): object {\n\t\tlet arr: object = {};\n\n\t\tvalue = value.replace(this.idPrefix(), '');\n\t\tlet idParts = value.split(this._pkeySeparator());\n\n\t\tif (pkey === null) {\n\t\t\tpkey = this.pkey();\n\t\t}\n\n\t\tif (pkey.length !== idParts.length) {\n\t\t\tthrow new Error('Primary key data does not match submitted data');\n\t\t}\n\n\t\tfor (let i = 0, ien = idParts.length; i < ien; i++) {\n\t\t\tif (flat) {\n\t\t\t\tarr[ pkey[i] ] = idParts[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis._writeProp(arr, pkey[i], idParts[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\t/**\n\t * Process a request from the Editor client-side to get / set data.\n\t * @param {IDtRequest} data Form data sent from the client-side -\n\t *   e.g. `req.body`\n\t * @param {IUpload} [files=null] File information, used for upload\n\t *   requests - e.g. `req.files`\n\t * @returns {Promise<Editor>} Promise that is fulfilled when Editor\n\t *   has completed its processing - result is the Editor instance.\n\t */\n\tpublic async process(data: IDtRequest, files: IUpload = null): Promise<Editor> {\n\t\tif (this._transaction) {\n\t\t\tlet processError;\n\n\t\t\ttry {\n\t\t\t\tawait this._db.transaction(async (trx) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis._knexTransaction = trx;\n\t\t\t\t\t\tawait this._process(data, files);\n\t\t\t\t\t\tthis._knexTransaction = null;\n\n\t\t\t\t\t\tawait trx.commit();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tprocessError = e;\n\t\t\t\t\t\tawait trx.rollback();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tif (this._tryCatch) {\n\t\t\t\t\tthis._out.error = processError.message;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow processError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this._tryCatch) {\n\t\t\t\ttry {\n\t\t\t\t\tawait this._process(data, files);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tthis._out.error = e.message;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tawait this._process(data, files);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the try/catch status.\n\t *\n\t * Editor uses a try/catch in the {@link Editor.process} method, and it can be\n\t * useful to disable this for debugging, but its not recommended you do that\n\t * in production.\n\t * @returns {boolean} Try / catch status.\n\t */\n\tpublic tryCatch(): boolean;\n\t/**\n\t * Set the try/catch state.\n\t * @param {boolean} tryCatch Value to set. `true` will enable, `false` disable.\n\t * @returns {Editor} Self for chaining.\n\t */\n\tpublic tryCatch(tryCatch: boolean): Editor;\n\tpublic tryCatch(tryCatch?: boolean): any {\n\t\tif (tryCatch === undefined) {\n\t\t\treturn this._tryCatch;\n\t\t}\n\n\t\tthis._tryCatch = tryCatch;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Perform validation on a data set.\n\t *\n\t * Note that validation is performed on data only when the action is\n\t * `create` or `edit`. Additionally, validation is performed on the _wire\n\t * data_ - i.e. that which is submitted from the client, without formatting.\n\t * Any formatting required by `setFormatter` is performed after the data\n\t * from the client has been validated.\n\t * @param {IDtError[]} errors Output array to which field error information will\n\t *   be written. Each element in the array represents a field in an error\n\t *   condition. These elements are themselves arrays with two properties\n\t *   set; `name` and `status`.\n\t * @param {IDtRequest} http The format data to check\n\t * @returns {Promise<boolean>} `true` if the data is valid, `false` if not.\n\t */\n\tpublic async validate(errors: IDtError[], http: IDtRequest): Promise<boolean> {\n\t\tif (this._doValidate === false) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (http.action !== 'create' && http.action !== 'edit') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet keys = Object.keys(http.data);\n\t\tlet fields = this.fields();\n\t\tlet idPrefix = this.idPrefix();\n\n\t\tfor (let i = 0, ien = keys.length; i < ien; i++) {\n\t\t\tlet values = http.data[ keys[i] ];\n\n\t\t\tfor (let j = 0, jen = fields.length; j < jen; j++) {\n\t\t\t\tlet field = fields[j];\n\t\t\t\tlet id = keys[i].replace(idPrefix, '');\n\t\t\t\tlet validation = await field.validate(values, this, id, http.action);\n\n\t\t\t\tif (validation !== true) {\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tname: field.name(),\n\t\t\t\t\t\tstatus: validation,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// MJoin validation\n\t\t\tfor (let j = 0, jen = this._join.length; j < jen; j++) {\n\t\t\t\tawait this._join[j].validate(errors, this, values, http.action);\n\t\t\t}\n\t\t}\n\n\t\treturn errors.length > 0 ?\n\t\t\tfalse :\n\t\t\ttrue;\n\t}\n\n\t/**\n\t * Get any global validator that has been set.\n\t * @returns {IGlobalValidator[]} Global validator\n\t */\n\tpublic validator(): IGlobalValidator[];\n\t/**\n\t * Set a global validator. This will be triggered for the create, edit\n\t * and remove actions performed from the client-side.\n\t * @param {IGlobalValidator} fn Function to execute when validating the input data.\n\t * @returns {Editor} Self for chaining\n\t */\n\tpublic validator(fn: IGlobalValidator): Editor;\n\tpublic validator(fn?: IGlobalValidator): any {\n\t\tif (fn === undefined) {\n\t\t\treturn this._validators;\n\t\t}\n\n\t\tthis._validators.push(fn);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the array of conditions applied to the method.\n\t * @returns {any[]} Knex where conditions.\n\t */\n\tpublic where(): any[];\n\t/**\n\t * Set a condition for the queries Editor will perform. Editor uses Knex\n\t * to connect to the database, and exposes the knex object using this method\n\t * so you can add any conditions you like that are supported by Knex.\n\t * @param {*} cond Knex query condition\n\t * @returns {Editor} Self for chaining.\n\t */\n\tpublic where(...cond: any[]): Editor;\n\tpublic where(...cond: any[]): any {\n\t\tif (cond.length === 0) {\n\t\t\treturn this._where;\n\t\t}\n\n\t\tthis._where.push(...cond);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clear out the `where` conditions already applied to this instance\n\t * @returns {Editor} Self for chaining.\n\t */\n\tpublic whereClear(): this {\n\t\tthis._where = [];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t* Getter/Setter for this._write which is used to decide which actions to allow\n\t* @param writeVal Value for this._write\n\t*/\n    public write(writeVal){\n\t   if(writeVal == undefined){\n\t\t   return this._write;\n\t   }\n\t   else if(typeof(writeVal) === \"boolean\") {\n\t\t   this._write = writeVal;\n\t\t   return this;\n\t   }\n\t   else {\n\t\t   return this;\n\t   }\n\t}\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n\tprivate async _fileClean(): Promise<void> {\n\t\tlet that = this;\n\t\tlet run = async function(fields) {\n\t\t\tfor (let i = 0, ien = fields.length; i < ien; i++) {\n\t\t\t\tlet upload = fields[i].upload();\n\n\t\t\t\tif (upload) {\n\t\t\t\t\tawait upload.dbCleanExec(that, fields[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tawait run(this._fields);\n\n\t\tfor (let i = 0, ien = this._join.length; i < ien; i++) {\n\t\t\tawait run(this._join[i].fields());\n\t\t}\n\t}\n\n\tprivate async _fileData(limitTable: string = null, ids: string[] = null, data: any[] = null): Promise<object> {\n\t\tlet files = {};\n\n\t\t// The fields in this instance\n\t\tawait this._fileDataFields(files, this._fields, limitTable, ids, data);\n\n\t\t// From joined tables\n\t\tfor (let i = 0, ien = this._join.length; i < ien; i++) {\n\t\t\tlet joinData = null;\n\n\t\t\t// If we have data from the get, it is nested from the join, so we need to\n\t\t\t// un-nest it (i.e. get the array of joined data for each row)\n\t\t\tif (data) {\n\t\t\t\tjoinData = [];\n\n\t\t\t\tfor (let j = 0, jen = data.length; j < jen ; j++) {\n\t\t\t\t\tlet innerData = data[j][this._join[i].name()];\n\n\t\t\t\t\tif (innerData) {\n\t\t\t\t\t\tjoinData.push.apply(joinData, innerData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait this._fileDataFields(files, this._join[i].fields(), limitTable, ids, joinData);\n\t\t}\n\n\t\treturn files;\n\t}\n\n\tprivate async _fileDataFields(\n\t\tfiles: object, fields: Field[], limitTable: string, ids: string[] = null, data: any[] = null\n\t): Promise<void> {\n\t\tfor (let i = 0, ien = fields.length; i < ien; i++) {\n\t\t\tlet upload = fields[i].upload();\n\n\t\t\tif (upload) {\n\t\t\t\tlet table = upload.table();\n\n\t\t\t\tif (! table) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (limitTable !== null && table !== limitTable) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (files[ table ]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Make a collection of the ids used in this data set to get a limited data set\n\t\t\t\t// in return (security and performance)\n\t\t\t\tif (ids === null) {\n\t\t\t\t\tids = [];\n\t\t\t\t}\n\n\t\t\t\tif (data !== null) {\n\t\t\t\t\tfor (let j = 0, jen = data.length; j < jen; j++) {\n\t\t\t\t\t\tlet val = fields[i].val('set', data[j]);\n\n\t\t\t\t\t\tif (val) {\n\t\t\t\t\t\t\tids.push(val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ids.length === 0) {\n\t\t\t\t\t\t// If no data to fetch, then don't bother\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ids.length > 1000) {\n\t\t\t\t\t\t// Don't use WHERE IN for really large arrays\n\t\t\t\t\t\tids = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet fileData = await upload.data(this.db(), ids);\n\n\t\t\t\tif (fileData) {\n\t\t\t\t\tfiles[ table ] = fileData;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _findField(name: string, type: 'db' | 'name'): Field {\n\t\tlet fields = this._fields;\n\n\t\tfor (let i = 0, ien = fields.length; i < ien; i++) {\n\t\t\tlet field = fields[i];\n\n\t\t\tif (field === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (type === 'name' && field.name() === name) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t\telse if (type === 'db' && field.dbField() === name) {\n\t\t\t\treturn field;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate async _get(id: string | string[], http = null): Promise<IDtResponse> {\n\t\tlet cancel = await this._trigger('preGet', id);\n\t\tif (cancel === false) {\n\t\t\treturn {};\n\t\t}\n\n\t\tlet fields = this.fields();\n\t\tlet pkeys = this.pkey();\n\t\tlet query = this.db().table(this._readTable()[0]);\n\t\tlet options = {};\n\n\t\tfor (let i = 0, ien = pkeys.length; i < ien; i++) {\n\t\t\tquery.select(pkeys[i] + ' as ' + pkeys[i]);\n\t\t}\n\n\t\tfor (let i = 0, ien = fields.length; i < ien; i++) {\n\t\t\tif (pkeys.includes(fields[i].dbField())) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (fields[i].apply('get') && fields[i].getValue() === undefined) {\n\t\t\t\t// Use the `as` to ensure that the table name is included, if using a join\n\t\t\t\tlet dbField = fields[i].dbField();\n\n\t\t\t\tif (dbField.indexOf('(') === -1) {\n\t\t\t\t\tquery.select(dbField + ' as ' + dbField);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquery.select(this.db().raw(dbField + ' as \"' + dbField + '\"'));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis._getWhere(query);\n\t\tthis._performLeftJoin(query);\n\n\t\tif (id !== null) {\n\t\t\t// Allow multiple specific rows to be requested at a time\n\t\t\tif (Array.isArray(id)) {\n\t\t\t\tquery.where(q => {\n\t\t\t\t\tfor (let ident of id) {\n\t\t\t\t\t\tq.orWhere(this.pkeyToObject(ident, true));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery.where(this.pkeyToObject(id, true));\n\t\t\t}\n\t\t}\n\n\t\t// If searchPanes is in use then add the options selected there to the where condition\n\t\tif (http !== null && http.searchPanes !== undefined && http.searchPanes !== null) {\n\t\t\tlet keys = Object.keys(http.searchPanes);\n\t\t\tfor (let key of keys) {\n\t\t\t\tquery.where(function() {\n\t\t\t\t\tfor (let val of http.searchPanes[key]) {\n\t\t\t\t\t\tthis.orWhere(key, val);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tlet ssp = await this._ssp(query, http);\n\n\t\tlet result = await query;\n\t\tif (! result) {\n\t\t\tthrow new Error('Error executing SQL for data get. Enable SQL debug using ' +\n\t\t\t\t'`debug: true` in your Knex db configuration'\n\t\t\t);\n\t\t}\n\n\t\tlet out = [];\n\t\tfor (let i = 0, ien = result.length; i < ien; i++) {\n\t\t\tlet inner = {\n\t\t\t\tDT_RowId: this.idPrefix() + this.pkeyToValue(result[i], true),\n\t\t\t};\n\n\t\t\tfor (let j = 0, jen = fields.length; j < jen; j++) {\n\t\t\t\tif (fields[j].apply('get') && fields[j].http()) {\n\t\t\t\t\tfields[j].write(inner, result[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.push(inner);\n\t\t}\n\n\t\tlet spOptions = {};\n\t\t// Field options and SearchPane Options\n\t\tif (id === null) {\n\t\t\tfor (let i = 0, ien = fields.length; i < ien; i++) {\n\t\t\t\tlet opts = await fields[i].optionsExec(this.db());\n\n\t\t\t\tif (opts) {\n\t\t\t\t\toptions[ fields[i].name() ] = opts;\n\t\t\t\t}\n\n\t\t\t\tlet spopts = await fields[i].searchPaneOptionsExec(fields[i], this, http, fields, this._leftJoin, this.db());\n\n\t\t\t\tif (spopts) {\n\t\t\t\t\tspOptions[fields[i].name()] = spopts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet searchPanes = {options: spOptions};\n\n\t\t// Build a DtResponse object\n\t\tlet response = {\n\t\t\tdata: out,\n\t\t\tdraw: ssp.draw,\n\t\t\tfiles: {},\n\t\t\toptions,\n\t\t\trecordsFiltered: ssp.recordsFiltered,\n\t\t\trecordsTotal: ssp.recordsTotal,\n\t\t\tsearchPanes\n\t\t};\n\n\t\t// Row based joins\n\t\tfor (let i = 0, ien = this._join.length; i < ien; i++) {\n\t\t\tawait this._join[i].data(this, response);\n\t\t}\n\n\t\tresponse.files = await this._fileData(null, null, response.data);\n\n\t\tawait this._trigger('postGet', id, out);\n\t\treturn response;\n\t}\n\n\tprivate _getWhere(query: knex.QueryBuilder): void {\n\t\tlet where = this.where();\n\n\t\tfor (let i = 0, ien = where.length; i < ien; i++) {\n\t\t\tquery.where(where[i]);\n\t\t}\n\t}\n\n\tprivate async _insert(values: object): Promise<string> {\n\t\t// Only allow a composite insert if the values for the key are\n\t\t// submitted. This is required because there is no reliable way in MySQL\n\t\t// to return the newly inserted row, so we can't know any newly\n\t\t// generated values.\n\t\tthis._pkeyValidateInsert(values);\n\n\t\tawait this._trigger('validatedCreate', values);\n\n\t\t// Insert the new row\n\t\tlet id = await this._insertOrUpdate(null, values);\n\n\t\tif (id === null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Was the primary key altered as part of the edit, if so use the\n\t\t// submitted values\n\t\tid = this._pkey.length > 1 ?\n\t\t\tthis.pkeyToValue(values) :\n\t\t\tthis._pkeySubmitMerge(id, values);\n\n\t\t// Join\n\t\tfor (let i = 0, ien = this._join.length; i < ien; i++) {\n\t\t\tawait this._join[i].create(this, id, values);\n\t\t}\n\n\t\tawait this._trigger('writeCreate', id, values);\n\n\t\treturn id;\n\t}\n\n\tprivate async _insertOrUpdate(id: string, values: object): Promise<string> {\n\t\t// Loop over the tables, doing the insert or update as needed\n\t\tlet tables = this.table();\n\n\t\tfor (let i = 0, ien = tables.length; i < ien; i++) {\n\t\t\tlet res = await this._insertOrUpdateTable(\n\t\t\t\ttables[i],\n\t\t\t\tvalues,\n\t\t\t\tid !== null ?\n\t\t\t\t\tthis.pkeyToObject(id, true) :\n\t\t\t\t\tnull\n\t\t\t);\n\n\t\t\t// If you don't have an id yet, then the first insert will return\n\t\t\t// the id we want\n\t\t\tif (res !== null && id === null) {\n\t\t\t\tid = res;\n\t\t\t}\n\t\t}\n\n\t\t// And for the left join tables\n\t\tfor (let i = 0, ien = this._leftJoin.length; i < ien; i++) {\n\t\t\tlet join = this._leftJoin[i];\n\n\t\t\t// Which side of the join refers to the parent table?\n\t\t\tlet joinTable = this._alias(join.table, 'alias');\n\t\t\tlet tablePart = this._part(join.field1);\n\t\t\tlet parentLink;\n\t\t\tlet childLink;\n\t\t\tlet whereVal;\n\n\t\t\tif (this._part(join.field1, 'db')) {\n\t\t\t\ttablePart = this._part(join.field1, 'db') + '.' + tablePart;\n\t\t\t}\n\n\t\t\tif (tablePart === joinTable) {\n\t\t\t\tparentLink = join.field2;\n\t\t\t\tchildLink = join.field1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tparentLink = join.field1;\n\t\t\t\tchildLink = join.field2;\n\t\t\t}\n\n\t\t\tif (parentLink === this._pkey[0] && this._pkey.length === 1) {\n\t\t\t\twhereVal = id;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We need submitted information about the joined data to be\n\t\t\t\t// submitted as well as the new value. We first check if the\n\t\t\t\t// host field was submitted\n\t\t\t\tlet field = this._findField(parentLink, 'db');\n\n\t\t\t\tif (! field || ! field.apply('edit', values)) {\n\t\t\t\t\t// If not, then check if the child id was submitted\n\t\t\t\t\tfield = this._findField(childLink, 'db');\n\n\t\t\t\t\tif (! field || ! field.apply('edit', values)) {\n\t\t\t\t\t\t// No data available, so we can't do anything\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhereVal = field.val('set', values);\n\t\t\t}\n\n\t\t\tlet whereName = this._part(childLink, 'column');\n\n\t\t\tawait this._insertOrUpdateTable(\n\t\t\t\tjoin.table,\n\t\t\t\tvalues,\n\t\t\t\t{ [whereName]: whereVal }\n\t\t\t);\n\t\t}\n\n\t\treturn id;\n\t}\n\n\tprivate async _insertOrUpdateTable(table: string, values: object, where: object = null) {\n\t\tlet set = {};\n\t\tlet res;\n\t\tlet action: 'create' | 'edit' = (where === null) ? 'create' : 'edit';\n\t\tlet tableAlias = this._alias(table, 'alias');\n\t\tlet fields = this.fields();\n\n\t\tfor (let i = 0, ien = fields.length; i < ien; i++) {\n\t\t\tlet field = fields[i];\n\t\t\tlet tablePart = this._part(field.dbField());\n\n\t\t\tif (this._part(field.dbField(), 'db')) {\n\t\t\t\ttablePart = this._part(field.dbField(), 'db') + '.' + tablePart;\n\t\t\t}\n\n\t\t\t// Does this field apply to the table (only check when a join is\n\t\t\t// being used)\n\t\t\tif (this._leftJoin.length && tablePart !== tableAlias) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Check if this field should be set, based on options and\n\t\t\t// submitted data\n\t\t\tif (! field.apply(action, values)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Some database's (specifically pg) don't like having the table\n\t\t\t// name prefixing the column name.\n\t\t\tlet fieldPart = this._part(field.dbField(), 'column');\n\t\t\tset[ fieldPart ] = field.val('set', values);\n\t\t}\n\n\t\tif (Object.keys(set).length === 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (action === 'create' && this.table().indexOf(table) !== -1) {\n\t\t\t// On the main table we get the pkey that is generated\n\t\t\tlet pkey = this._part(this._pkey[0], 'column');\n\t\t\tres = await this\n\t\t\t\t.db()\n\t\t\t\t.insert(set)\n\t\t\t\t.table(table)\n\t\t\t\t.returning(pkey);\n\n\t\t\treturn typeof res[0] === 'object' ?\n\t\t\t\tres[0][pkey].toString() :\n\t\t\t\tres[0].toString();\n\t\t}\n\t\telse if (action === 'create') {\n\t\t\t// Create on a linked table\n\t\t\tres = await this\n\t\t\t\t.db()\n\t\t\t\t.insert(set)\n\t\t\t\t.table(table);\n\t\t}\n\t\telse if (this.table().indexOf(table) === -1) {\n\t\t\t// Update on a linked table - the record might not yet exist, so need to check.\n\t\t\tlet check = await this\n\t\t\t\t.db()\n\t\t\t\t.table(table)\n\t\t\t\t.select('*')\n\t\t\t\t.where(where);\n\n\t\t\tif (check && check.length) {\n\t\t\t\tawait this\n\t\t\t\t\t.db()\n\t\t\t\t\t.table(table)\n\t\t\t\t\t.update(set)\n\t\t\t\t\t.where(where);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tawait this\n\t\t\t\t\t.db()\n\t\t\t\t\t.table(table)\n\t\t\t\t\t.insert({...set, ...where});\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Update on the host table\n\t\t\tawait this\n\t\t\t\t.db()\n\t\t\t\t.table(table)\n\t\t\t\t.update(set)\n\t\t\t\t.where(where);\n\t\t}\n\t}\n\n\tprivate _alias(name: string, type: 'alias' | 'orig' = 'alias'): string {\n\t\tif (name.indexOf(' as ') !== -1) {\n\t\t\tlet a = name.split(/ as /i);\n\t\t\treturn type === 'alias' ?\n\t\t\t\ta[1] :\n\t\t\t\ta[0];\n\t\t}\n\n\t\tif (name.indexOf(' ') !== -1) {\n\t\t\tlet a = name.split(/ /i);\n\t\t\treturn type === 'alias' ?\n\t\t\t\ta[1] :\n\t\t\t\ta[0];\n\t\t}\n\n\t\treturn name;\n\t}\n\n\tprivate _part(name: string, type: 'table' | 'db' | 'column' = 'table'): string {\n\t\tlet db;\n\t\tlet table;\n\t\tlet column;\n\n\t\tif (name.indexOf('.') !== -1) {\n\t\t\tlet a = name.split('.');\n\n\t\t\tif (a.length === 3) {\n\t\t\t\tdb = a[0];\n\t\t\t\ttable = a[1];\n\t\t\t\tcolumn = a[2];\n\t\t\t}\n\t\t\telse if (a.length === 2) {\n\t\t\t\ttable = a[0];\n\t\t\t\tcolumn = a[1];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcolumn = name;\n\t\t}\n\n\t\tif (type === 'db') {\n\t\t\treturn db;\n\t\t}\n\t\telse if (type === 'table') {\n\t\t\treturn table;\n\t\t}\n\t\treturn column;\n\t}\n\n\tprivate _prepJoin(): void {\n\t\tif (this._leftJoin.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if the primary key has a table identifier - if not - add one\n\t\tfor (let i = 0, ien = this._pkey.length; i < ien; i++) {\n\t\t\tlet val = this._pkey[i];\n\n\t\t\tif (val.indexOf('.') === -1) {\n\t\t\t\tthis._pkey[i] = this._alias(this.table()[0], 'alias') + '.' + val;\n\t\t\t}\n\t\t}\n\n\t\t// Check that all fields have a table selector, otherwise, we'd need to\n\t\t// know the structure of the tables, to know which fields belong in\n\t\t// which. This extra requirement on the fields removes that\n\t\tfor (let i = 0, ien = this._fields.length; i < ien; i++) {\n\t\t\tlet field = this._fields[i];\n\t\t\tlet name = field.dbField();\n\n\t\t\tif (name.indexOf('.') === -1) {\n\t\t\t\tthrow new Error('Table part of the field \"' + name + '\" was not found. ' +\n\t\t\t\t\t'In Editor instances that use a join, all fields must have the ' +\n\t\t\t\t\t'database table set explicitly.'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _performLeftJoin(query: knex.QueryBuilder): void {\n\t\tfor (let i = 0, ien = this._leftJoin.length; i < ien; i++) {\n\t\t\tlet join = this._leftJoin[i];\n\n\t\t\tquery.leftJoin(join.table, function() {\n\t\t\t\tthis.on(join.field1, join.operator, join.field2);\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _pkeySeparator(): string {\n\t\tlet str = this.pkey().join(',');\n\n\t\treturn crc.crc32(str).toString(16);\n\t}\n\n\tprivate _pkeySubmitMerge(pkeyVal: string, row: object): string {\n\t\tlet pkey = this._pkey;\n\t\tlet arr = this.pkeyToObject(pkeyVal, true);\n\n\t\tfor (let i = 0, ien = pkey.length; i < ien; i++) {\n\t\t\tlet column = pkey[ i ];\n\t\t\tlet field = this._findField(column, 'db');\n\n\t\t\tif (field && field.apply('edit', row)) {\n\t\t\t\tarr[ column ] = field.val('set', row);\n\t\t\t}\n\t\t}\n\n\t\treturn this.pkeyToValue(arr, true);\n\t}\n\n\tprivate _pkeyValidateInsert(row: object): boolean {\n\t\tlet pkey = this.pkey();\n\n\t\tif (pkey.length === 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\tfor (let i = 0, ien = pkey.length; i < ien; i++) {\n\t\t\tlet column = pkey[i];\n\t\t\tlet field = this._findField(column, 'db');\n\n\t\t\tif (! field || ! field.apply('create', row)) {\n\t\t\t\tthrow new Error('When inserting into a compound key table, ' +\n\t\t\t\t\t'all fields that are part of the compound key must be ' +\n\t\t\t\t\t'submitted with a specific value.'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate async _process(data: IDtRequest, upload: IUpload): Promise<void> {\n\t\tthis._out = {\n\t\t\tcancelled: [],\n\t\t\tdata: [],\n\t\t\tfieldErrors: []\n\t\t};\n\n\t\tthis._processData = data;\n\t\tthis._uploadData = upload;\n\t\tthis._formData = data.data ? data.data : null;\n\t\tthis._prepJoin();\n\n\t\tfor (let validator of this._validators) {\n\t\t\tlet ret = await validator(this, data.action, data);\n\n\t\t\tif (typeof ret === 'string') {\n\t\t\t\tthis._out.error = ret;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (data.action && data.action !== 'upload' && ! data.data) {\n\t\t\tthis._out.error = 'No data detected. Have you used `{extended: true}` for `bodyParser`?';\n\t\t}\n\n\t\tlet action = Editor.action(data);\n\n\t\tif (! this._out.error) {\n\t\t\tif (action === Action.Read) {\n\t\t\t\tlet outData = await this._get(null, data);\n\n\t\t\t\tthis._out.data = outData.data;\n\t\t\t\tthis._out.draw = outData.draw;\n\t\t\t\tthis._out.files = outData.files;\n\t\t\t\tthis._out.options = outData.options;\n\t\t\t\tthis._out.recordsTotal = outData.recordsTotal;\n\t\t\t\tthis._out.recordsFiltered = outData.recordsFiltered;\n\t\t\t\tthis._out.searchPanes = outData.searchPanes;\n\t\t\t}\n\t\t\telse if (action === Action.Upload && this._write) {\n\t\t\t\tawait this._upload(data);\n\t\t\t}\n\t\t\telse if (action === Action.Delete && this._write) {\n\t\t\t\tawait this._remove(data);\n\t\t\t\tawait this._fileClean();\n\t\t\t}\n\t\t\telse if ((action === Action.Create || action === Action.Edit) && this._write) {\n\t\t\t\t// create or edit\n\t\t\t\tlet keys = Object.keys(data.data);\n\n\t\t\t\t// Pre events so they can occur before validation, and they\n\t\t\t\t// all happen together\n\t\t\t\tfor (let i = 0, ien = keys.length; i < ien; i++) {\n\t\t\t\t\tlet cancel = null;\n\t\t\t\t\tlet idSrc = keys[i];\n\t\t\t\t\tlet values = data.data[keys[i]];\n\n\t\t\t\t\tif (action === Action.Create) {\n\t\t\t\t\t\tcancel = await this._trigger('preCreate', values);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet id = idSrc.replace(this.idPrefix(), '');\n\t\t\t\t\t\tcancel = await this._trigger('preEdit', id, values);\n\t\t\t\t\t}\n\n\t\t\t\t\t// One of the event handlers returned false - don't continue\n\t\t\t\t\tif (cancel === false) {\n\t\t\t\t\t\t// Remove the data from the data set so it won't be processed\n\t\t\t\t\t\tdelete data.data[ idSrc ];\n\n\t\t\t\t\t\t// Tell the client-side we aren't updating this row\n\t\t\t\t\t\tthis._out.cancelled.push(idSrc);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Field validation\n\t\t\t\tlet valid = await this.validate(this._out.fieldErrors, data);\n\t\t\t\tlet pkeys = [];\n\t\t\t\tlet eventName = action === Action.Create ?\n\t\t\t\t\t'Create' :\n\t\t\t\t\t'Edit';\n\t\t\t\n\t\t\t\tif (valid) {\n\t\t\t\t\tkeys = Object.keys(data.data);\n\n\t\t\t\t\t// Perform db insert / update\n\t\t\t\t\tfor (let key of keys) {\n\t\t\t\t\t\tlet pkey = action === Action.Create ?\n\t\t\t\t\t\t\tawait this._insert(data.data[key]) :\n\t\t\t\t\t\t\tawait this._update(key, data.data[key]);\n\n\t\t\t\t\t\tpkeys.push({\n\t\t\t\t\t\t\tdataKey: this.idPrefix() + pkey,\n\t\t\t\t\t\t\tpkey,\n\t\t\t\t\t\t\tsubmitKey: key, // could be array index (create)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Remap the submitted data from the submitted key to the row id\n\t\t\t\t\t// This isn't just row id without the prefix, since the create is\n\t\t\t\t\t// array indexed\n\t\t\t\t\tlet submitedData = {};\n\t\t\t\t\tObject.keys(data.data).forEach(key => {\n\t\t\t\t\t\tlet k = pkeys.find(p => p.submitKey === key);\n\t\t\t\t\t\tsubmitedData[k.pkey] = data.data[key];\n\t\t\t\t\t});\n\n\t\t\t\t\t// All writes done - trigger `All`\n\t\t\t\t\tawait this._trigger(\n\t\t\t\t\t\t`write${eventName}All`,\n\t\t\t\t\t\tpkeys.map(k => k.pkey),\n\t\t\t\t\t\tsubmitedData\n\t\t\t\t\t);\n\n\t\t\t\t\t// Get the data that was updated in a single query\n\t\t\t\t\tlet returnData = await this._get(pkeys.map(k => k.pkey));\n\t\t\t\t\tthis._out.data = returnData.data;\n\n\t\t\t\t\t// post events\n\t\t\t\t\tfor (let key of pkeys) {\n\t\t\t\t\t\tawait this._trigger(\n\t\t\t\t\t\t\t`post${eventName}`,\n\t\t\t\t\t\t\tkey.pkey,\n\t\t\t\t\t\t\tdata.data[key.submitKey],\n\t\t\t\t\t\t\treturnData.data.find(row => row['DT_RowId'] === key.dataKey)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait this._trigger(\n\t\t\t\t\t\t`post${eventName}All`,\n\t\t\t\t\t\tpkeys.map(k => k.pkey),\n\t\t\t\t\t\tsubmitedData,\n\t\t\t\t\t\treturnData.data\n\t\t\t\t\t);\n\n\t\t\t\t\t// File tidy up\n\t\t\t\t\tawait this._fileClean();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this._debug) {\n\t\t\tthis._out.debug = this._debugInfo.slice();\n\t\t}\n\t}\n\n\tprivate _readTable(): string[] {\n\t\treturn this._readTableNames.length ?\n\t\t\tthis._readTableNames :\n\t\t\tthis._table;\n\t}\n\n\tprivate async _remove(http: IDtRequest): Promise<void> {\n\t\tlet ids: string[] = [];\n\t\tlet keys = Object.keys(http.data);\n\n\t\tfor (let i = 0, ien = keys.length; i < ien; i++) {\n\t\t\t// Strip the ID prefix that the client-side sends back\n\t\t\tlet id = keys[i].replace(this.idPrefix(), '');\n\n\t\t\tlet res = await this._trigger('preRemove', id, http.data[keys[i]]);\n\n\t\t\t// Allow the event to be cancelled and inform the client-side\n\t\t\tif (res === false) {\n\t\t\t\tthis._out.cancelled.push(id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tids.push(id);\n\t\t\t}\n\t\t}\n\n\t\tif (ids.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Row based joins - remove first as the host row will be removed which\n\t\t// is a dependency\n\t\tfor (let i = 0, ien = this._join.length; i < ien; i++) {\n\t\t\tawait this._join[i].remove(this, ids);\n\t\t}\n\n\t\t// Remove from the left join tables\n\t\tif (this._leftJoinRemove) {\n\t\t\tfor (let i = 0, ien = this._leftJoin.length; i < ien; i++) {\n\t\t\t\tlet join = this._leftJoin[i];\n\t\t\t\tlet table = this._alias(join.table, 'orig');\n\t\t\t\tlet parentLink;\n\t\t\t\tlet childLink;\n\n\t\t\t\t// Which side of the join refers to the parent table?\n\t\t\t\tif (join.field1.indexOf(join.table) === 0) {\n\t\t\t\t\tparentLink = join.field2;\n\t\t\t\t\tchildLink = join.field1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparentLink = join.field1;\n\t\t\t\t\tchildLink = join.field2;\n\t\t\t\t}\n\n\t\t\t\t// Only delete on the primary key, since that is what the ids refer\n\t\t\t\t// to - otherwise we'd be deleting random data! Note that this\n\t\t\t\t// won't work with compound keys since the parent link would be\n\t\t\t\t// over multiple fields.\n\t\t\t\tif (parentLink === this._pkey[0] && this._pkey.length === 1) {\n\t\t\t\t\tawait this._removeTable(join.table, ids, [childLink]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Remove from the primary tables\n\t\tlet tables = this.table();\n\n\t\tfor (let i = 0, ien = tables.length; i < ien; i++) {\n\t\t\tawait this._removeTable(tables[i], ids);\n\t\t}\n\n\t\tfor (let i = 0, ien = ids.length; i < ien; i++) {\n\t\t\tawait this._trigger('postRemove', ids[i], http.data[ this.idPrefix() + ids[i] ]);\n\t\t}\n\t}\n\n\tprivate async _removeTable(table: string, ids: string[], pkey: string[] = null): Promise<void> {\n\t\tif (pkey === null) {\n\t\t\tpkey = this.pkey();\n\t\t}\n\n\t\t// Check that there is actually a field which has a set option for this table\n\t\tlet count = 0;\n\t\tlet fields = this.fields();\n\t\tlet tableAlias = this._alias(table, 'alias');\n\t\tlet tableOrig = this._alias(table, 'orig');\n\n\t\t// This is a bit 'iffy', but required since knex delete does not support delete with an alias\n\t\t// and our pkey might have an alias. If that's the case, need to replace. The `pkeySeparator`\n\t\t// method uses `this.pkey()` which is how we get away with this.\n\t\tfor (let i = 0, ien = pkey.length; i < ien; i++) {\n\t\t\tif (pkey[i].indexOf(tableAlias + '.') === 0) {\n\t\t\t\tpkey[i] = pkey[i].replace(tableAlias + '.', tableOrig + '.');\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0, ien = fields.length; i < ien; i++) {\n\t\t\tlet dbField = fields[i].dbField();\n\n\t\t\tif (dbField.indexOf('.') === -1 ||\n\t\t\t\t(this._part(dbField, 'table') === tableAlias && fields[i].set() !== SetType.None)\n\t\t\t) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\tlet q = this.db().from(tableOrig);\n\n\t\t\tfor (let i = 0, ien = ids.length; i < ien; i++) {\n\t\t\t\tlet cond = this.pkeyToObject(ids[i], true, pkey);\n\n\t\t\t\tq.orWhere(function() {\n\t\t\t\t\tthis.where(cond);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tawait q.del();\n\t\t}\n\t}\n\n\tprivate async _ssp(query: knex.QueryBuilder, http: IDtRequest): Promise<ISSP> {\n\t\tif (! http || ! http.draw) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Add the server-side processing conditions to the get query\n\t\tthis._sspLimit(query, http);\n\t\tthis._sspSort(query, http);\n\t\tthis._sspFilter(query, http);\n\n\t\t// Get the number of rows in the result set\n\t\tlet setCount = this\n\t\t\t.db()\n\t\t\t.from(this._readTable()[0])\n\t\t\t.count(this._pkey[0] + ' as cnt');\n\n\t\tthis._getWhere(setCount);\n\t\tthis._sspFilter(setCount, http);\n\t\tthis._performLeftJoin(setCount);\n\t\tlet res = await setCount;\n\t\tlet recordsFiltered = (res[0] as any).cnt;\n\n\t\t// Get the number of rows in the full set\n\t\tlet fullCount = this\n\t\t\t.db()\n\t\t\t.from(this._readTable()[0])\n\t\t\t.count(this._pkey[0] + ' as cnt');\n\n\t\tthis._getWhere(fullCount);\n\t\tif (this._where.length) { // only needed if there is a where condition\n\t\t\tthis._performLeftJoin(fullCount);\n\t\t}\n\t\tres = await fullCount;\n\t\tlet recordsTotal = (res[0] as any).cnt;\n\n\t\treturn {\n\t\t\tdraw: http.draw * 1,\n\t\t\trecordsFiltered,\n\t\t\trecordsTotal\n\t\t};\n\t}\n\n\tprivate _sspField(http: IDtRequest, index: number): string {\n\t\tlet name = http.columns[ index ].data;\n\t\tlet field = this._findField(name, 'name');\n\n\t\tif (! field) {\n\t\t\t// Is it the primary key?\n\t\t\tif (name === 'DT_RowId') {\n\t\t\t\treturn this._pkey[0];\n\t\t\t}\n\n\t\t\tthrow new Error('Unknown field: ' + name + ' (index ' + index + ')');\n\t\t}\n\n\t\treturn field.dbField();\n\t}\n\n\tprivate _sspFilter(query: knex.QueryBuilder, http): void {\n\t\tlet fields = this.fields();\n\n\t\t// Global filter\n\t\tif (http.search.value) {\n\t\t\tquery.where((q) => {\n\t\t\t\tfor (let i = 0, ien = http.columns.length; i < ien; i++) {\n\t\t\t\t\tif (http.columns[i].searchable.toString() === 'true') {\n\t\t\t\t\t\tlet field = this._sspField(http, i);\n\n\t\t\t\t\t\tif (field) {\n\t\t\t\t\t\t\t// Nasty hack for Postgres\n\t\t\t\t\t\t\tif (this._db.client.config.client === 'pg') {\n\t\t\t\t\t\t\t\tq.orWhereRaw('??::text ILIKE ?',[field,'%' + http.search.value + '%']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tq.orWhere(field, 'LIKE', '%' + http.search.value + '%');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (http.searchPanes !== null && http.searchPanes !== undefined) {\n\t\t\tfor (let field of fields) {\n\t\t\t\tif (http.searchPanes[field.name()] !== undefined) {\n\t\t\t\t\tquery.where(function() {\n\t\t\t\t\t\tfor (let opt of http.searchPanes[field.name()]) {\n\t\t\t\t\t\t\tthis.orWhere(field.name(), opt);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Column filter\n\t\tfor (let i = 0, ien = http.columns.length; i < ien; i++) {\n\t\t\tlet column = http.columns[i];\n\t\t\tlet search = column.search.value;\n\n\t\t\tif (search !== '' && column.searchable.toString() === 'true') {\n\t\t\t\t// Nasty hack for Postgres\n\t\t\t\tif (this._db.client.config.client === 'pg') {\n\t\t\t\t\tquery.whereRaw(\n\t\t\t\t\t\t'??::text ILIKE ?',\n\t\t\t\t\t\t[this._sspField(http, i),'%' + search + '%']\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tquery.where(\n\t\t\t\t\t\tthis._sspField(http, i),\n\t\t\t\t\t\t'LIKE',\n\t\t\t\t\t\t'%' + search + '%'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _sspLimit(query: knex.QueryBuilder, http: IDtRequest): void {\n\t\tif (http.length !== -1) { // -1 is 'show all' in DataTables\n\t\t\tquery\n\t\t\t\t.limit(http.length * 1)\n\t\t\t\t.offset(http.start * 1);\n\t\t}\n\t}\n\n\tprivate _sspSort(query: knex.QueryBuilder, http: IDtRequest): void {\n\t\tfor (let i = 0, ien = http.order.length; i < ien; i++) {\n\t\t\tlet order = http.order[i];\n\n\t\t\tquery.orderBy(\n\t\t\t\tthis._sspField(http, order.column),\n\t\t\t\torder.dir === 'asc' ? 'asc' : 'desc'\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate async _trigger(name: string, ...args): Promise<boolean> {\n\t\tlet out = null;\n\t\tlet events = this._events[ name ];\n\n\t\tif (! this._events[ name ]) {\n\t\t\treturn;\n\t\t}\n\n\t\targs.unshift(this);\n\n\t\tfor (let i = 0, ien = events.length; i < ien; i++) {\n\t\t\tlet res = await events[i].apply(this, args);\n\n\t\t\tif (res !== null) {\n\t\t\t\tout = res;\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t}\n\n\tprivate async _update(id: string, values: object): Promise<string> {\n\t\tid = id.replace(this.idPrefix(), '');\n\n\t\tawait this._trigger('validatedEdit', id, values);\n\n\t\t// Update or insert the rows for the parent table and the left joined\n\t\t// tables\n\t\tawait this._insertOrUpdate(id, values);\n\n\t\t// Join\n\t\tfor (let i = 0, ien = this._join.length; i < ien; i++) {\n\t\t\tawait this._join[i].update(this, id, values);\n\t\t}\n\n\t\t// Was the primary key altered as part of the edit, if so use the\n\t\t// submitted values\n\t\tlet getId = this._pkeySubmitMerge(id, values);\n\n\t\tawait this._trigger('writeEdit', id, values);\n\n\t\treturn getId;\n\t}\n\n\tprivate async _upload(http: IDtRequest): Promise<void> {\n\t\t// Search for the upload field in the local fields\n\t\tlet field = this._findField(http.uploadField, 'name');\n\t\tlet fieldName = '';\n\n\t\tif (! field) {\n\t\t\t// Perhaps it is in a join instance\n\t\t\tfor (let i = 0, ien = this._join.length; i < ien; i++) {\n\t\t\t\tlet join = this._join[i];\n\t\t\t\tlet fields = join.fields();\n\n\t\t\t\tfor (let j = 0, jen = fields.length; j < jen; j++) {\n\t\t\t\t\tlet joinField = fields[j];\n\t\t\t\t\tlet name = join.name() + '[].' + joinField.name();\n\n\t\t\t\t\tif (name === http.uploadField) {\n\t\t\t\t\t\tfield = joinField;\n\t\t\t\t\t\tfieldName = name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfieldName = field.name();\n\t\t}\n\n\t\tif (! this._uploadData) {\n\t\t\tthrow new Error('No upload data supplied');\n\t\t}\n\n\t\tif (! field) {\n\t\t\tthrow new Error('Unknown upload field name submitted');\n\t\t}\n\n\t\tlet eventRes = await this._trigger('preUpload', http);\n\n\t\t// Allow the upload to be cancelled by an event handler\n\t\tif (eventRes === false) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet upload = field.upload();\n\t\tif (! upload) {\n\t\t\tthrow new Error('File uploaded to a field that does not have upload options configured');\n\t\t}\n\n\t\tlet res = await upload.exec(this, this._uploadData);\n\n\t\tif (! res) {\n\t\t\tthis._out.fieldErrors.push({\n\t\t\t\tname: fieldName,\n\t\t\t\tstatus: upload.error()\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tlet files = await this._fileData(upload.table(), [res]);\n\n\t\t\tthis._out.files = files;\n\t\t\tthis._out.upload = {\n\t\t\t\tid: res\n\t\t\t};\n\t\t}\n\t}\n}\n"]}