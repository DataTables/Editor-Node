{"version":3,"sources":["field.ts"],"names":[],"mappings":"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","file":"field.d.ts","sourcesContent":["import * as knex from 'knex';\n\nimport Editor, {IDtRequest} from './editor';\nimport {IFormatter} from './formatters';\nimport NestedData from './nestedData';\nimport Options, {CustomOptions, IOption} from './options';\nimport SearchPaneOptions from './searchPaneOptions';\nimport Upload from './upload';\nimport Validator, {IValidator} from './validators';\nimport xss, {Ixss} from './xss';\n\n/**\n * Set types\n * @export\n */\nexport enum SetType {\n\t/** Do not set data */\n\tNone,\n\n\t/** Write to database on both create and edit */\n\tBoth,\n\n\t/** Write to the database only on create */\n\tCreate,\n\n\t/** Write to the database only on edit */\n\tEdit\n}\n\n/**\n * Field definitions for the DataTables Editor.\n *\n * Each Database column that is used with Editor can be described with this\n * Field method (both for Editor and Join instances). It basically tells\n * Editor what table column to use, how to format the data and if you want\n * to read and/or write this column.\n *\n * Field instances are used with the {@link Editor.field} and\n * {@link Mjoin.field} methods to describe what fields should be interacted\n * with by the editable table.\n *\n * @export\n * @class Field\n * @extends {NestedData}\n */\nexport default class Field extends NestedData {\n\tpublic static SetType = SetType;\n\n\tprivate _dbField: string;\n\tprivate _get: boolean = true;\n\tprivate _getFormatter: IFormatter;\n\tprivate _getValue: any;\n\tprivate _http: boolean = true;\n\tprivate _opts: Options & CustomOptions;\n\tprivate _name: string;\n\tprivate _spopts: SearchPaneOptions;\n\tprivate _set: SetType = SetType.Both;\n\tprivate _setFormatter: IFormatter;\n\tprivate _setValue: any;\n\tprivate _validator: Array<{setFormatted: boolean; validator: IValidator}> = [];\n\tprivate _upload: Upload;\n\tprivate _xss: Ixss;\n\tprivate _xssFormat: boolean = true;\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\t/**\n\t * Creates an instance of Field.\n\t *\n\t * @param {string} [dbField=null] Name of the database column\n\t * @param {string} [name=null] Name to use in the JSON output from Editor and the\n\t *   HTTP submit from the client-side when editing. If not given then the\n\t *   `dbField` name is used.\n\t */\n\tconstructor(dbField: string = null, name: string = null) {\n\t\tsuper();\n\n\t\tif (! name && dbField) {\n\t\t\t// Standard usage, a single parameter\n\t\t\tthis\n\t\t\t\t.name(dbField)\n\t\t\t\t.dbField(dbField);\n\t\t}\n\t\telse {\n\t\t\tthis\n\t\t\t\t.name(name)\n\t\t\t\t.dbField(dbField);\n\t\t}\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Get the database column name\n\t *\n\t * @returns {string} Configured column name\n\t */\n\tpublic dbField(): string;\n\t/**\n\t * Set the database column name\n\t *\n\t * @param {string} dbField Column name to set\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic dbField(dbField: string): Field;\n\tpublic dbField(dbField?: string): any {\n\t\tif (dbField === undefined) {\n\t\t\treturn this._dbField;\n\t\t}\n\n\t\tthis._dbField = dbField;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the `get` flag for the field (i.e. if the field should be\n\t * read from the database).\n\t *\n\t * @returns {boolean} True if gettable, false otherwise.\n\t */\n\tpublic get(): boolean;\n\t/**\n\t * Set the `get` flag.\n\t *\n\t * @param {boolean} flag `true` to mark as readable, false otherwise\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic get(flag: boolean): Field;\n\tpublic get(flag?: boolean): any {\n\t\tif (flag === undefined) {\n\t\t\treturn this._get;\n\t\t}\n\n\t\tthis._get = flag;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get formatter for the field's data.\n\t *\n\t * @returns {IFormatter} Formatter\n\t */\n\tpublic getFormatter(): IFormatter;\n\t/**\n\t * Set the get formatter.\n\t *\n\t * When the data has been retrieved from the server, it can be passed through\n\t * a formatter here, which will manipulate (format) the data as required. This\n\t * can be useful when, for example, working with dates and a particular format\n\t * is required on the client-side.\n\t *\n\t * @param {IFormatter} formatter Formatter to use.\n\t * @returns {Field} Self for chaining.\n\t */\n\tpublic getFormatter(formatter: IFormatter): Field;\n\tpublic getFormatter(formatter?: IFormatter): any {\n\t\tif (formatter === undefined) {\n\t\t\treturn this._getFormatter;\n\t\t}\n\n\t\tthis._getFormatter = formatter;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the currently applied get value.\n\t *\n\t * @returns {*} Value - will be undefined by default.\n\t */\n\tpublic getValue(): any;\n\t/**\n\t * Set the get value for the field.\n\t *\n\t * If given, then this value is used to send to the client-side, regardless\n\t * of what value is held by the database.\n\t *\n\t * @param {*} val Value to set\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic getValue(val: any): Field;\n\tpublic getValue(val?: any): any {\n\t\tif (val === undefined) {\n\t\t\treturn this._getValue;\n\t\t}\n\n\t\tthis._getValue = val;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicator to say if this field can be read over http (i.e. externally)\n\t */\n\tpublic http(): boolean;\n\t/**\n\t * Set indicator to say if the field can be read via http\n\t */\n\tpublic http(set: boolean): Field;\n\tpublic http(set?: boolean): any {\n\t\tif (set === undefined) {\n\t\t\treturn this._http;\n\t\t}\n\n\t\tthis._http = set;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the field's configured name.\n\t *\n\t * @returns {string} Current name.\n\t */\n\tpublic name(): string;\n\t/**\n\t * Set the field's name.\n\t *\n\t * The name is typically the same as the dbField name, since it makes things\n\t * less confusing(!), but it is possible to set a different name for the data\n\t * which is used in the JSON returned to DataTables in a 'get' operation and\n\t * the field name used in a 'set' operation.\n\t *\n\t * @param {string} name Name to set\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic name(name: string): Field;\n\tpublic name(name?: string): any {\n\t\tif (name === undefined) {\n\t\t\treturn this._name;\n\t\t}\n\n\t\tthis._name = name;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the currently configured options for the field.\n\t *\n\t * @returns {(Options & CustomOptions)} Options configuration\n\t */\n\tpublic options(): Options & CustomOptions;\n\t/**\n\t * Set how a list of options (values and labels) will be retrieved for the field.\n\t *\n\t * Gets a list of values that can be used for the options list in radio,\n\t * select and checkbox inputs from the database for this field.\n\t *\n\t * Note that this is for simple 'label / value' pairs only. For more complex\n\t * data, including pairs that require joins and where conditions, use a\n\t * closure to provide a query\n\t *\n\t * @param {(Options & CustomOptions)} opts Options configuration\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic options(opts: Options & CustomOptions): Field;\n\tpublic options(opts?: Options & CustomOptions): any {\n\t\tif (opts === undefined) {\n\t\t\treturn this._opts;\n\t\t}\n\n\t\tthis._opts = opts;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set how a list iof options (values and labels) will be retrieved for the fields searchpane.\n\t *\n\t * Gets a list of values that can be used for the options list in searchpanes.\n\t *\n\t * @param spopts: SearchPaneOptions\n\t * @return this\n\t */\n\tpublic searchPaneOptions(): SearchPaneOptions;\n\tpublic searchPaneOptions(spopts: SearchPaneOptions): Field;\n\tpublic searchPaneOptions(spopts?: SearchPaneOptions): any {\n\t\tif (spopts === undefined) {\n\t\t\treturn this._spopts;\n\t\t}\n\n\t\tthis._spopts = spopts;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the current `set` property for the field.\n\t *\n\t * @returns {SetType} Set configuration\n\t */\n\tpublic set(): SetType;\n\t/**\n\t * Set the field's `set` configuration.\n\t *\n\t * A field can be marked as read only using this option, to be set only\n\t * during an create or edit action or to be set during both actions. This\n\t * provides the ability to have fields that are only set when a new row is\n\t * created (for example a \"created\" time stamp).\n\t *\n\t * @param {(boolean|SetType)} flag Set flag.\n\t * @returns {Field} Self for chaining.\n\t */\n\tpublic set(flag: boolean | SetType): Field;\n\tpublic set(flag?: boolean): any {\n\t\tif (flag === undefined) {\n\t\t\treturn this._set;\n\t\t}\n\n\t\tif (flag === true) {\n\t\t\tthis._set = SetType.Both;\n\t\t}\n\t\telse if (flag === false) {\n\t\t\tthis._set = SetType.None;\n\t\t}\n\t\telse {\n\t\t\tthis._set = flag;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set formatter for the field's data.\n\t *\n\t * @returns {IFormatter} Formatter\n\t */\n\tpublic setFormatter(): IFormatter;\n\t/**\n\t * Set the set formatter.\n\t *\n\t * When the data has been retrieved from the server, it can be passed through\n\t * a formatter here, which will manipulate (format) the data as required. This\n\t * can be useful when, for example, working with dates and a particular format\n\t * is required on the client-side.\n\t *\n\t * Editor has a number of formatters available with the {@link Format} class\n\t * which can be used directly with this method.\n\t *\n\t * @param {IFormatter} formatter Formatter to use.\n\t * @returns {Field} Self for chaining.\n\t */\n\tpublic setFormatter(formatter: IFormatter): Field;\n\tpublic setFormatter(formatter?: IFormatter): any {\n\t\tif (formatter === undefined) {\n\t\t\treturn this._setFormatter;\n\t\t}\n\n\t\tthis._setFormatter = formatter;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the currently applied set value.\n\t *\n\t * @returns {*} Value - will be undefined by default.\n\t */\n\tpublic setValue(): any;\n\t/**\n\t * Set the set value for the field.\n\t *\n\t * If given, then this value is used to write to the database regardless\n\t *  of what data is sent from the client-side.\n\t *\n\t * @param {*} val Value to set\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic setValue(val: any): Field;\n\tpublic setValue(val?: any): any {\n\t\tif (val === undefined) {\n\t\t\treturn this._setValue;\n\t\t}\n\n\t\tthis._setValue = val;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the {@link Upload} class for this field.\n\t *\n\t * @returns {Upload} Configured upload class\n\t */\n\tpublic upload(): Upload;\n\t/**\n\t * Set an {@link Upload} class for this field.\n\t *\n\t * @param {Upload} upload Upload class instance\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic upload(upload: Upload): Field;\n\tpublic upload(upload?: Upload): any {\n\t\tif (upload === undefined) {\n\t\t\treturn this._upload;\n\t\t}\n\n\t\tthis._upload = upload;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the validators applied to this field.\n\t *\n\t * @returns {IValidator[]} Array of validators\n\t */\n\tpublic validator(): IValidator[];\n\t/**\n\t * Set the 'validator' of the field.\n\t *\n\t * The validator can be used to check if any abstract piece of data is valid\n\t * or not according to the given rules of the validation function used.\n\t *\n\t * Multiple validation options can be applied to a field instance by calling\n\t * this method multiple times. For example, it would be possible to have a\n\t * 'required' validation and a 'maxLength' validation with multiple calls.\n\t *\n\t * Editor has a number of validation available with the {@link Validate} class\n\t * which can be used directly with this method.\n\t *\n\t * @param {IValidator} validator Validator to add to the field\n\t * @returns {Field} Self for chaining\n\t */\n\tpublic validator(validator: IValidator, setFormatted?: boolean): Field;\n\tpublic validator(validator?: IValidator, setFormatted = false): any {\n\t\tif ( validator === undefined ) {\n\t\t\treturn this._validator.map((v) => v.validator);\n\t\t}\n\n\t\tthis._validator.push( {\n\t\t\tsetFormatted,\n\t\t\tvalidator\n\t\t} );\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the current XSS formatter.\n\t *\n\t * @returns {Ixss} XSS formatter. Can be null or undefined.\n\t */\n\tpublic xss(): Ixss;\n\t/**\n\t * Set a formatting method that will be used for XSS checking / removal.\n\t * This should be a function that takes a single argument (the value to be\n\t * cleaned) and returns the cleaned value.\n\t *\n\t * Editor will use `xss-filters` by default for this operation, which is built\n\t * into the software and no additional configuration is required, but a\n\t * custom function can be used if you wish to use a different formatter.\n\t *\n\t * If you wish to disable this option (which you would only do if you are\n\t * absolutely confident that your validation will pick up on any XSS inputs)\n\t * simply provide a closure function that returns the value given to the\n\t * function. This is _not_ recommended.\n\t *\n\t * @param {(boolean|Ixss)} flag Enable / disable XSS protection, or set a\n\t *   formatter.\n\t * @returns {Field} Self for chaining.\n\t */\n\tpublic xss(flag: boolean | Ixss): Field;\n\tpublic xss(flag?: boolean | Ixss): any {\n\t\tif (flag === undefined) {\n\t\t\treturn this._xss;\n\t\t}\n\n\t\tif (flag === true) {\n\t\t\tthis._xss = xss;\n\t\t}\n\t\telse if (flag === false) {\n\t\t\tthis._xss = null;\n\t\t}\n\t\telse {\n\t\t\tthis._xss = flag;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Internal methods\n\t * Used by the Editor class and not generally for public use\n\t */\n\n\t/**\n\t * @hidden\n\t */\n\tpublic apply(action: 'get' | 'create' | 'edit', data?: object): boolean {\n\t\tif (action === 'get') {\n\t\t\treturn this._get;\n\t\t}\n\n\t\tif (action === 'create' && (this._set === SetType.None || this._set === SetType.Edit)) {\n\t\t\treturn false;\n\t\t}\n\t\telse if (action === 'edit' && (this._set === SetType.None || this._set === SetType.Create)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check it was in the submitted data\n\t\tif (this._setValue === undefined && ! this._propExists(this.name(), data)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// In the data set, so use it\n\t\treturn true;\n\t}\n\n\t/**\n\t * @hidden\n\t */\n\tpublic async optionsExec(db: knex): Promise<false | IOption[]> {\n\t\tif (this._opts instanceof Options) {\n\t\t\treturn this._opts.exec(db);\n\t\t}\n\t\telse if (this._opts) {\n\t\t\treturn (this._opts as any)(db);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @hidden\n\t */\n\tpublic async searchPaneOptionsExec(\n\t\tfield: Field, editor: Editor, http, fields: Field[], leftJoin, db: knex\n\t): Promise<false | IOption[]> {\n\t\tif (this._spopts instanceof SearchPaneOptions) {\n\t\t\tlet retVal = await this._spopts.exec(field, editor, http, fields, leftJoin);\n\t\t\treturn retVal;\n\t\t}\n\t\telse if (this._spopts) {\n\t\t\treturn (this._spopts as any)(db, editor);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @hidden\n\t */\n\tpublic val(direction: 'get' | 'set', data: object): any {\n\t\tlet val;\n\n\t\tif (direction === 'get') {\n\t\t\tif (this._getValue !== undefined) {\n\t\t\t\tval = typeof this._getValue === 'function' ?\n\t\t\t\t\tthis._getValue() :\n\t\t\t\t\tthis._getValue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Getting data, so db field name\n\t\t\t\tval = data[ this._dbField ] !== undefined ?\n\t\t\t\t\tdata[ this._dbField ] :\n\t\t\t\t\tnull;\n\t\t\t}\n\n\t\t\treturn this._format(val, data, this._getFormatter);\n\t\t}\n\n\t\t// set - using from the payload, and thus use `name`\n\t\tif (this._setValue !== undefined) {\n\t\t\tval = typeof this._setValue === 'function' ?\n\t\t\t\tthis._setValue() :\n\t\t\t\tthis._setValue;\n\t\t}\n\t\telse {\n\t\t\tval = this._readProp(this._name, data);\n\t\t}\n\n\t\treturn this._format(val, data, this._setFormatter);\n\t}\n\n\t/**\n\t * @hidden\n\t */\n\tpublic async validate(data: object, editor: Editor, id: string = null, action: IDtRequest['action']): Promise<true | string> {\n\t\tif (this._validator.length === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet val = this._readProp(this.name(), data);\n\t\tlet host = new Validator.Host({\n\t\t\taction,\n\t\t\tdb: editor.db(),\n\t\t\teditor,\n\t\t\tfield: this,\n\t\t\tid\n\t\t});\n\n\t\tfor ( let i = 0, ien = this._validator.length ; i < ien ; i++ ) {\n\t\t\tlet validator = this._validator[i].validator;\n\t\t\tlet testVal = this._validator[i].setFormatted\n\t\t\t\t? this.val('set', data)\n\t\t\t\t: val;\n\n\t\t\tlet res = await validator( testVal, data, host );\n\n\t\t\tif (res !== true) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t// Validation methods all run, must be value\n\t\treturn true;\n\t}\n\n\t/**\n\t * @hidden\n\t */\n\tpublic write(out: object, srcData: object): void {\n\t\tthis._writeProp(out, this.name(), this.val('get', srcData));\n\t}\n\n\t/**\n\t * @hidden\n\t */\n\tpublic xssSafety(val: any) {\n\t\tif (! this._xss) {\n\t\t\treturn val;\n\t\t}\n\n\t\tif (Array.isArray(val)) {\n\t\t\tlet out = [];\n\n\t\t\tfor (let i = 0, ien = val.length ; i < ien ; i++) {\n\t\t\t\tout.push(this._xss(val[i]));\n\t\t\t}\n\n\t\t\treturn out;\n\t\t}\n\n\t\treturn this._xss(val);\n\t}\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n\tprivate _format(val: any, data: object, formatter: IFormatter): any {\n\t\treturn formatter ?\n\t\t\tformatter(val, data) :\n\t\t\tval;\n\t}\n}\n"]}